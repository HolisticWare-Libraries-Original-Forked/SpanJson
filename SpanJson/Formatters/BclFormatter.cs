using System;
using System.Collections.Generic;
using SpanJson.Helpers;
using System.Buffers;

// Autogenerated
// ReSharper disable BuiltInTypeReferenceStyle
namespace SpanJson.Formatters
{
    public sealed class SByteUtf16Formatter : IJsonFormatter<SByte, Char>, IJsonFormatterStaticDefault<SByte, Char, SByteUtf16Formatter>
    {
        public static IJsonFormatter<SByte, Char> Default {get;} = new SByteUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, SByte value)
        {
            writer.WriteUtf16SByte(value);
        }

        public SByte Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16SByte();
        }
    }
    public sealed class NullableSByteUtf16Formatter : IJsonFormatter<SByte?, Char>, IJsonFormatterStaticDefault<SByte?, Char, NullableSByteUtf16Formatter>
    {
        public static IJsonFormatter<SByte?, Char> Default {get;} = new NullableSByteUtf16Formatter();
        private static readonly SByteUtf16Formatter ElementFormatter = (SByteUtf16Formatter) SByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, SByte? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public SByte? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSByteUtf16ArrayFormatter : IJsonFormatter<SByte?[], Char>, IJsonFormatterStaticDefault<SByte?[], Char, NullableSByteUtf16ArrayFormatter>
    {
        public static IJsonFormatter<SByte?[], Char> Default {get;} = new NullableSByteUtf16ArrayFormatter();
        private static readonly NullableSByteUtf16Formatter ElementFormatter = (NullableSByteUtf16Formatter) NullableSByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, SByte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public SByte?[] Deserialize(ref JsonReader<Char> reader)
        {
            SByte?[] temp = null;
            SByte?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<SByte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableSByteUtf16ListFormatter : IJsonFormatter<List<SByte?>, Char>, IJsonFormatterStaticDefault<List<SByte?>, Char, NullableSByteUtf16ListFormatter>
    {
        public static IJsonFormatter<List<SByte?>, Char> Default {get;} = new NullableSByteUtf16ListFormatter();
        private static readonly NullableSByteUtf16Formatter ElementFormatter = (NullableSByteUtf16Formatter) NullableSByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<SByte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<SByte?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<SByte?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<SByte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SByteUtf16ArrayFormatter : IJsonFormatter<SByte[], Char>, IJsonFormatterStaticDefault<SByte[], Char, SByteUtf16ArrayFormatter>
    {
        public static IJsonFormatter<SByte[], Char> Default {get;} = new SByteUtf16ArrayFormatter();
        private static readonly SByteUtf16Formatter ElementFormatter = (SByteUtf16Formatter) SByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, SByte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public SByte[] Deserialize(ref JsonReader<Char> reader)
        {
            SByte[] temp = null;
            SByte[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<SByte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SByteUtf16ListFormatter : IJsonFormatter<List<SByte>, Char>, IJsonFormatterStaticDefault<List<SByte>, Char, SByteUtf16ListFormatter>
    {
        public static IJsonFormatter<List<SByte>, Char> Default {get;} = new SByteUtf16ListFormatter();
        private static readonly SByteUtf16Formatter ElementFormatter = (SByteUtf16Formatter) SByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<SByte> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<SByte>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<SByte> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<SByte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class SByteUtf8Formatter : IJsonFormatter<SByte, Byte>, IJsonFormatterStaticDefault<SByte, Byte, SByteUtf8Formatter>
    {
        public static IJsonFormatter<SByte, Byte> Default {get;} = new SByteUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, SByte value)
        {
            writer.WriteUtf8SByte(value);
        }

        public SByte Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8SByte();
        }
    }
    public sealed class NullableSByteUtf8Formatter : IJsonFormatter<SByte?, Byte>, IJsonFormatterStaticDefault<SByte?, Byte, NullableSByteUtf8Formatter>
    {
        public static IJsonFormatter<SByte?, Byte> Default {get;} = new NullableSByteUtf8Formatter();
        private static readonly SByteUtf8Formatter ElementFormatter = (SByteUtf8Formatter) SByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, SByte? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public SByte? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSByteUtf8ArrayFormatter : IJsonFormatter<SByte?[], Byte>, IJsonFormatterStaticDefault<SByte?[], Byte, NullableSByteUtf8ArrayFormatter>
    {
        public static IJsonFormatter<SByte?[], Byte> Default {get;} = new NullableSByteUtf8ArrayFormatter();
        private static readonly NullableSByteUtf8Formatter ElementFormatter = (NullableSByteUtf8Formatter) NullableSByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, SByte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public SByte?[] Deserialize(ref JsonReader<Byte> reader)
        {
            SByte?[] temp = null;
            SByte?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<SByte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableSByteUtf8ListFormatter : IJsonFormatter<List<SByte?>, Byte>, IJsonFormatterStaticDefault<List<SByte?>, Byte, NullableSByteUtf8ListFormatter>
    {
        public static IJsonFormatter<List<SByte?>, Byte> Default {get;} = new NullableSByteUtf8ListFormatter();
        private static readonly NullableSByteUtf8Formatter ElementFormatter = (NullableSByteUtf8Formatter) NullableSByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<SByte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<SByte?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<SByte?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<SByte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SByteUtf8ArrayFormatter : IJsonFormatter<SByte[], Byte>, IJsonFormatterStaticDefault<SByte[], Byte, SByteUtf8ArrayFormatter>
    {
        public static IJsonFormatter<SByte[], Byte> Default {get;} = new SByteUtf8ArrayFormatter();
        private static readonly SByteUtf8Formatter ElementFormatter = (SByteUtf8Formatter) SByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, SByte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public SByte[] Deserialize(ref JsonReader<Byte> reader)
        {
            SByte[] temp = null;
            SByte[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<SByte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<SByte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<SByte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SByteUtf8ListFormatter : IJsonFormatter<List<SByte>, Byte>, IJsonFormatterStaticDefault<List<SByte>, Byte, SByteUtf8ListFormatter>
    {
        public static IJsonFormatter<List<SByte>, Byte> Default {get;} = new SByteUtf8ListFormatter();
        private static readonly SByteUtf8Formatter ElementFormatter = (SByteUtf8Formatter) SByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<SByte> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<SByte>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<SByte> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<SByte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int16Utf16Formatter : IJsonFormatter<Int16, Char>, IJsonFormatterStaticDefault<Int16, Char, Int16Utf16Formatter>
    {
        public static IJsonFormatter<Int16, Char> Default {get;} = new Int16Utf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Int16 value)
        {
            writer.WriteUtf16Int16(value);
        }

        public Int16 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int16();
        }
    }
    public sealed class NullableInt16Utf16Formatter : IJsonFormatter<Int16?, Char>, IJsonFormatterStaticDefault<Int16?, Char, NullableInt16Utf16Formatter>
    {
        public static IJsonFormatter<Int16?, Char> Default {get;} = new NullableInt16Utf16Formatter();
        private static readonly Int16Utf16Formatter ElementFormatter = (Int16Utf16Formatter) Int16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int16? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Int16? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt16Utf16ArrayFormatter : IJsonFormatter<Int16?[], Char>, IJsonFormatterStaticDefault<Int16?[], Char, NullableInt16Utf16ArrayFormatter>
    {
        public static IJsonFormatter<Int16?[], Char> Default {get;} = new NullableInt16Utf16ArrayFormatter();
        private static readonly NullableInt16Utf16Formatter ElementFormatter = (NullableInt16Utf16Formatter) NullableInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int16?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Int16?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int16?[] temp = null;
            Int16?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int16?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt16Utf16ListFormatter : IJsonFormatter<List<Int16?>, Char>, IJsonFormatterStaticDefault<List<Int16?>, Char, NullableInt16Utf16ListFormatter>
    {
        public static IJsonFormatter<List<Int16?>, Char> Default {get;} = new NullableInt16Utf16ListFormatter();
        private static readonly NullableInt16Utf16Formatter ElementFormatter = (NullableInt16Utf16Formatter) NullableInt16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Int16?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int16?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Int16?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int16?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int16Utf16ArrayFormatter : IJsonFormatter<Int16[], Char>, IJsonFormatterStaticDefault<Int16[], Char, Int16Utf16ArrayFormatter>
    {
        public static IJsonFormatter<Int16[], Char> Default {get;} = new Int16Utf16ArrayFormatter();
        private static readonly Int16Utf16Formatter ElementFormatter = (Int16Utf16Formatter) Int16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int16[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Int16[] Deserialize(ref JsonReader<Char> reader)
        {
            Int16[] temp = null;
            Int16[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int16>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int16Utf16ListFormatter : IJsonFormatter<List<Int16>, Char>, IJsonFormatterStaticDefault<List<Int16>, Char, Int16Utf16ListFormatter>
    {
        public static IJsonFormatter<List<Int16>, Char> Default {get;} = new Int16Utf16ListFormatter();
        private static readonly Int16Utf16Formatter ElementFormatter = (Int16Utf16Formatter) Int16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Int16> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int16>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Int16> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int16>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int16Utf8Formatter : IJsonFormatter<Int16, Byte>, IJsonFormatterStaticDefault<Int16, Byte, Int16Utf8Formatter>
    {
        public static IJsonFormatter<Int16, Byte> Default {get;} = new Int16Utf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Int16 value)
        {
            writer.WriteUtf8Int16(value);
        }

        public Int16 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int16();
        }
    }
    public sealed class NullableInt16Utf8Formatter : IJsonFormatter<Int16?, Byte>, IJsonFormatterStaticDefault<Int16?, Byte, NullableInt16Utf8Formatter>
    {
        public static IJsonFormatter<Int16?, Byte> Default {get;} = new NullableInt16Utf8Formatter();
        private static readonly Int16Utf8Formatter ElementFormatter = (Int16Utf8Formatter) Int16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int16? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Int16? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt16Utf8ArrayFormatter : IJsonFormatter<Int16?[], Byte>, IJsonFormatterStaticDefault<Int16?[], Byte, NullableInt16Utf8ArrayFormatter>
    {
        public static IJsonFormatter<Int16?[], Byte> Default {get;} = new NullableInt16Utf8ArrayFormatter();
        private static readonly NullableInt16Utf8Formatter ElementFormatter = (NullableInt16Utf8Formatter) NullableInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int16?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Int16?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int16?[] temp = null;
            Int16?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int16?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt16Utf8ListFormatter : IJsonFormatter<List<Int16?>, Byte>, IJsonFormatterStaticDefault<List<Int16?>, Byte, NullableInt16Utf8ListFormatter>
    {
        public static IJsonFormatter<List<Int16?>, Byte> Default {get;} = new NullableInt16Utf8ListFormatter();
        private static readonly NullableInt16Utf8Formatter ElementFormatter = (NullableInt16Utf8Formatter) NullableInt16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Int16?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int16?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Int16?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int16?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int16Utf8ArrayFormatter : IJsonFormatter<Int16[], Byte>, IJsonFormatterStaticDefault<Int16[], Byte, Int16Utf8ArrayFormatter>
    {
        public static IJsonFormatter<Int16[], Byte> Default {get;} = new Int16Utf8ArrayFormatter();
        private static readonly Int16Utf8Formatter ElementFormatter = (Int16Utf8Formatter) Int16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int16[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Int16[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int16[] temp = null;
            Int16[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int16>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int16>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int16Utf8ListFormatter : IJsonFormatter<List<Int16>, Byte>, IJsonFormatterStaticDefault<List<Int16>, Byte, Int16Utf8ListFormatter>
    {
        public static IJsonFormatter<List<Int16>, Byte> Default {get;} = new Int16Utf8ListFormatter();
        private static readonly Int16Utf8Formatter ElementFormatter = (Int16Utf8Formatter) Int16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Int16> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int16>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Int16> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int16>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int32Utf16Formatter : IJsonFormatter<Int32, Char>, IJsonFormatterStaticDefault<Int32, Char, Int32Utf16Formatter>
    {
        public static IJsonFormatter<Int32, Char> Default {get;} = new Int32Utf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Int32 value)
        {
            writer.WriteUtf16Int32(value);
        }

        public Int32 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int32();
        }
    }
    public sealed class NullableInt32Utf16Formatter : IJsonFormatter<Int32?, Char>, IJsonFormatterStaticDefault<Int32?, Char, NullableInt32Utf16Formatter>
    {
        public static IJsonFormatter<Int32?, Char> Default {get;} = new NullableInt32Utf16Formatter();
        private static readonly Int32Utf16Formatter ElementFormatter = (Int32Utf16Formatter) Int32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int32? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Int32? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt32Utf16ArrayFormatter : IJsonFormatter<Int32?[], Char>, IJsonFormatterStaticDefault<Int32?[], Char, NullableInt32Utf16ArrayFormatter>
    {
        public static IJsonFormatter<Int32?[], Char> Default {get;} = new NullableInt32Utf16ArrayFormatter();
        private static readonly NullableInt32Utf16Formatter ElementFormatter = (NullableInt32Utf16Formatter) NullableInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int32?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Int32?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int32?[] temp = null;
            Int32?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int32?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt32Utf16ListFormatter : IJsonFormatter<List<Int32?>, Char>, IJsonFormatterStaticDefault<List<Int32?>, Char, NullableInt32Utf16ListFormatter>
    {
        public static IJsonFormatter<List<Int32?>, Char> Default {get;} = new NullableInt32Utf16ListFormatter();
        private static readonly NullableInt32Utf16Formatter ElementFormatter = (NullableInt32Utf16Formatter) NullableInt32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Int32?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int32?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Int32?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int32?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int32Utf16ArrayFormatter : IJsonFormatter<Int32[], Char>, IJsonFormatterStaticDefault<Int32[], Char, Int32Utf16ArrayFormatter>
    {
        public static IJsonFormatter<Int32[], Char> Default {get;} = new Int32Utf16ArrayFormatter();
        private static readonly Int32Utf16Formatter ElementFormatter = (Int32Utf16Formatter) Int32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int32[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Int32[] Deserialize(ref JsonReader<Char> reader)
        {
            Int32[] temp = null;
            Int32[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int32>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int32Utf16ListFormatter : IJsonFormatter<List<Int32>, Char>, IJsonFormatterStaticDefault<List<Int32>, Char, Int32Utf16ListFormatter>
    {
        public static IJsonFormatter<List<Int32>, Char> Default {get;} = new Int32Utf16ListFormatter();
        private static readonly Int32Utf16Formatter ElementFormatter = (Int32Utf16Formatter) Int32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Int32> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int32>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Int32> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int32>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int32Utf8Formatter : IJsonFormatter<Int32, Byte>, IJsonFormatterStaticDefault<Int32, Byte, Int32Utf8Formatter>
    {
        public static IJsonFormatter<Int32, Byte> Default {get;} = new Int32Utf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Int32 value)
        {
            writer.WriteUtf8Int32(value);
        }

        public Int32 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int32();
        }
    }
    public sealed class NullableInt32Utf8Formatter : IJsonFormatter<Int32?, Byte>, IJsonFormatterStaticDefault<Int32?, Byte, NullableInt32Utf8Formatter>
    {
        public static IJsonFormatter<Int32?, Byte> Default {get;} = new NullableInt32Utf8Formatter();
        private static readonly Int32Utf8Formatter ElementFormatter = (Int32Utf8Formatter) Int32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int32? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Int32? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt32Utf8ArrayFormatter : IJsonFormatter<Int32?[], Byte>, IJsonFormatterStaticDefault<Int32?[], Byte, NullableInt32Utf8ArrayFormatter>
    {
        public static IJsonFormatter<Int32?[], Byte> Default {get;} = new NullableInt32Utf8ArrayFormatter();
        private static readonly NullableInt32Utf8Formatter ElementFormatter = (NullableInt32Utf8Formatter) NullableInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int32?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Int32?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int32?[] temp = null;
            Int32?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int32?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt32Utf8ListFormatter : IJsonFormatter<List<Int32?>, Byte>, IJsonFormatterStaticDefault<List<Int32?>, Byte, NullableInt32Utf8ListFormatter>
    {
        public static IJsonFormatter<List<Int32?>, Byte> Default {get;} = new NullableInt32Utf8ListFormatter();
        private static readonly NullableInt32Utf8Formatter ElementFormatter = (NullableInt32Utf8Formatter) NullableInt32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Int32?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int32?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Int32?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int32?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int32Utf8ArrayFormatter : IJsonFormatter<Int32[], Byte>, IJsonFormatterStaticDefault<Int32[], Byte, Int32Utf8ArrayFormatter>
    {
        public static IJsonFormatter<Int32[], Byte> Default {get;} = new Int32Utf8ArrayFormatter();
        private static readonly Int32Utf8Formatter ElementFormatter = (Int32Utf8Formatter) Int32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int32[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Int32[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int32[] temp = null;
            Int32[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int32>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int32>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int32Utf8ListFormatter : IJsonFormatter<List<Int32>, Byte>, IJsonFormatterStaticDefault<List<Int32>, Byte, Int32Utf8ListFormatter>
    {
        public static IJsonFormatter<List<Int32>, Byte> Default {get;} = new Int32Utf8ListFormatter();
        private static readonly Int32Utf8Formatter ElementFormatter = (Int32Utf8Formatter) Int32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Int32> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int32>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Int32> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int32>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int64Utf16Formatter : IJsonFormatter<Int64, Char>, IJsonFormatterStaticDefault<Int64, Char, Int64Utf16Formatter>
    {
        public static IJsonFormatter<Int64, Char> Default {get;} = new Int64Utf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Int64 value)
        {
            writer.WriteUtf16Int64(value);
        }

        public Int64 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Int64();
        }
    }
    public sealed class NullableInt64Utf16Formatter : IJsonFormatter<Int64?, Char>, IJsonFormatterStaticDefault<Int64?, Char, NullableInt64Utf16Formatter>
    {
        public static IJsonFormatter<Int64?, Char> Default {get;} = new NullableInt64Utf16Formatter();
        private static readonly Int64Utf16Formatter ElementFormatter = (Int64Utf16Formatter) Int64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int64? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Int64? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt64Utf16ArrayFormatter : IJsonFormatter<Int64?[], Char>, IJsonFormatterStaticDefault<Int64?[], Char, NullableInt64Utf16ArrayFormatter>
    {
        public static IJsonFormatter<Int64?[], Char> Default {get;} = new NullableInt64Utf16ArrayFormatter();
        private static readonly NullableInt64Utf16Formatter ElementFormatter = (NullableInt64Utf16Formatter) NullableInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int64?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Int64?[] Deserialize(ref JsonReader<Char> reader)
        {
            Int64?[] temp = null;
            Int64?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int64?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt64Utf16ListFormatter : IJsonFormatter<List<Int64?>, Char>, IJsonFormatterStaticDefault<List<Int64?>, Char, NullableInt64Utf16ListFormatter>
    {
        public static IJsonFormatter<List<Int64?>, Char> Default {get;} = new NullableInt64Utf16ListFormatter();
        private static readonly NullableInt64Utf16Formatter ElementFormatter = (NullableInt64Utf16Formatter) NullableInt64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Int64?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int64?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Int64?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int64?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int64Utf16ArrayFormatter : IJsonFormatter<Int64[], Char>, IJsonFormatterStaticDefault<Int64[], Char, Int64Utf16ArrayFormatter>
    {
        public static IJsonFormatter<Int64[], Char> Default {get;} = new Int64Utf16ArrayFormatter();
        private static readonly Int64Utf16Formatter ElementFormatter = (Int64Utf16Formatter) Int64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Int64[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Int64[] Deserialize(ref JsonReader<Char> reader)
        {
            Int64[] temp = null;
            Int64[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int64>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int64Utf16ListFormatter : IJsonFormatter<List<Int64>, Char>, IJsonFormatterStaticDefault<List<Int64>, Char, Int64Utf16ListFormatter>
    {
        public static IJsonFormatter<List<Int64>, Char> Default {get;} = new Int64Utf16ListFormatter();
        private static readonly Int64Utf16Formatter ElementFormatter = (Int64Utf16Formatter) Int64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Int64> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int64>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Int64> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Int64>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class Int64Utf8Formatter : IJsonFormatter<Int64, Byte>, IJsonFormatterStaticDefault<Int64, Byte, Int64Utf8Formatter>
    {
        public static IJsonFormatter<Int64, Byte> Default {get;} = new Int64Utf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Int64 value)
        {
            writer.WriteUtf8Int64(value);
        }

        public Int64 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Int64();
        }
    }
    public sealed class NullableInt64Utf8Formatter : IJsonFormatter<Int64?, Byte>, IJsonFormatterStaticDefault<Int64?, Byte, NullableInt64Utf8Formatter>
    {
        public static IJsonFormatter<Int64?, Byte> Default {get;} = new NullableInt64Utf8Formatter();
        private static readonly Int64Utf8Formatter ElementFormatter = (Int64Utf8Formatter) Int64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int64? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Int64? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableInt64Utf8ArrayFormatter : IJsonFormatter<Int64?[], Byte>, IJsonFormatterStaticDefault<Int64?[], Byte, NullableInt64Utf8ArrayFormatter>
    {
        public static IJsonFormatter<Int64?[], Byte> Default {get;} = new NullableInt64Utf8ArrayFormatter();
        private static readonly NullableInt64Utf8Formatter ElementFormatter = (NullableInt64Utf8Formatter) NullableInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int64?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Int64?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int64?[] temp = null;
            Int64?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int64?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableInt64Utf8ListFormatter : IJsonFormatter<List<Int64?>, Byte>, IJsonFormatterStaticDefault<List<Int64?>, Byte, NullableInt64Utf8ListFormatter>
    {
        public static IJsonFormatter<List<Int64?>, Byte> Default {get;} = new NullableInt64Utf8ListFormatter();
        private static readonly NullableInt64Utf8Formatter ElementFormatter = (NullableInt64Utf8Formatter) NullableInt64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Int64?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int64?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Int64?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int64?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class Int64Utf8ArrayFormatter : IJsonFormatter<Int64[], Byte>, IJsonFormatterStaticDefault<Int64[], Byte, Int64Utf8ArrayFormatter>
    {
        public static IJsonFormatter<Int64[], Byte> Default {get;} = new Int64Utf8ArrayFormatter();
        private static readonly Int64Utf8Formatter ElementFormatter = (Int64Utf8Formatter) Int64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Int64[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Int64[] Deserialize(ref JsonReader<Byte> reader)
        {
            Int64[] temp = null;
            Int64[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Int64>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Int64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Int64>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class Int64Utf8ListFormatter : IJsonFormatter<List<Int64>, Byte>, IJsonFormatterStaticDefault<List<Int64>, Byte, Int64Utf8ListFormatter>
    {
        public static IJsonFormatter<List<Int64>, Byte> Default {get;} = new Int64Utf8ListFormatter();
        private static readonly Int64Utf8Formatter ElementFormatter = (Int64Utf8Formatter) Int64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Int64> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Int64>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Int64> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Int64>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class ByteUtf16Formatter : IJsonFormatter<Byte, Char>, IJsonFormatterStaticDefault<Byte, Char, ByteUtf16Formatter>
    {
        public static IJsonFormatter<Byte, Char> Default {get;} = new ByteUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Byte value)
        {
            writer.WriteUtf16Byte(value);
        }

        public Byte Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Byte();
        }
    }
    public sealed class NullableByteUtf16Formatter : IJsonFormatter<Byte?, Char>, IJsonFormatterStaticDefault<Byte?, Char, NullableByteUtf16Formatter>
    {
        public static IJsonFormatter<Byte?, Char> Default {get;} = new NullableByteUtf16Formatter();
        private static readonly ByteUtf16Formatter ElementFormatter = (ByteUtf16Formatter) ByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Byte? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Byte? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableByteUtf16ArrayFormatter : IJsonFormatter<Byte?[], Char>, IJsonFormatterStaticDefault<Byte?[], Char, NullableByteUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Byte?[], Char> Default {get;} = new NullableByteUtf16ArrayFormatter();
        private static readonly NullableByteUtf16Formatter ElementFormatter = (NullableByteUtf16Formatter) NullableByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Byte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Byte?[] Deserialize(ref JsonReader<Char> reader)
        {
            Byte?[] temp = null;
            Byte?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Byte?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableByteUtf16ListFormatter : IJsonFormatter<List<Byte?>, Char>, IJsonFormatterStaticDefault<List<Byte?>, Char, NullableByteUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Byte?>, Char> Default {get;} = new NullableByteUtf16ListFormatter();
        private static readonly NullableByteUtf16Formatter ElementFormatter = (NullableByteUtf16Formatter) NullableByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Byte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Byte?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Byte?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Byte?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class ByteUtf16ArrayFormatter : IJsonFormatter<Byte[], Char>, IJsonFormatterStaticDefault<Byte[], Char, ByteUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Byte[], Char> Default {get;} = new ByteUtf16ArrayFormatter();
        private static readonly ByteUtf16Formatter ElementFormatter = (ByteUtf16Formatter) ByteUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Byte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Byte[] Deserialize(ref JsonReader<Char> reader)
        {
            Byte[] temp = null;
            Byte[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Byte>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class ByteUtf16ListFormatter : IJsonFormatter<List<Byte>, Char>, IJsonFormatterStaticDefault<List<Byte>, Char, ByteUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Byte>, Char> Default {get;} = new ByteUtf16ListFormatter();
        private static readonly ByteUtf16Formatter ElementFormatter = (ByteUtf16Formatter) ByteUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Byte> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Byte>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Byte> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Byte>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class ByteUtf8Formatter : IJsonFormatter<Byte, Byte>, IJsonFormatterStaticDefault<Byte, Byte, ByteUtf8Formatter>
    {
        public static IJsonFormatter<Byte, Byte> Default {get;} = new ByteUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Byte value)
        {
            writer.WriteUtf8Byte(value);
        }

        public Byte Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Byte();
        }
    }
    public sealed class NullableByteUtf8Formatter : IJsonFormatter<Byte?, Byte>, IJsonFormatterStaticDefault<Byte?, Byte, NullableByteUtf8Formatter>
    {
        public static IJsonFormatter<Byte?, Byte> Default {get;} = new NullableByteUtf8Formatter();
        private static readonly ByteUtf8Formatter ElementFormatter = (ByteUtf8Formatter) ByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Byte? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Byte? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableByteUtf8ArrayFormatter : IJsonFormatter<Byte?[], Byte>, IJsonFormatterStaticDefault<Byte?[], Byte, NullableByteUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Byte?[], Byte> Default {get;} = new NullableByteUtf8ArrayFormatter();
        private static readonly NullableByteUtf8Formatter ElementFormatter = (NullableByteUtf8Formatter) NullableByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Byte?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Byte?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Byte?[] temp = null;
            Byte?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Byte?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableByteUtf8ListFormatter : IJsonFormatter<List<Byte?>, Byte>, IJsonFormatterStaticDefault<List<Byte?>, Byte, NullableByteUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Byte?>, Byte> Default {get;} = new NullableByteUtf8ListFormatter();
        private static readonly NullableByteUtf8Formatter ElementFormatter = (NullableByteUtf8Formatter) NullableByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Byte?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Byte?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Byte?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Byte?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class ByteUtf8ArrayFormatter : IJsonFormatter<Byte[], Byte>, IJsonFormatterStaticDefault<Byte[], Byte, ByteUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Byte[], Byte> Default {get;} = new ByteUtf8ArrayFormatter();
        private static readonly ByteUtf8Formatter ElementFormatter = (ByteUtf8Formatter) ByteUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Byte[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Byte[] Deserialize(ref JsonReader<Byte> reader)
        {
            Byte[] temp = null;
            Byte[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Byte>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Byte>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Byte>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class ByteUtf8ListFormatter : IJsonFormatter<List<Byte>, Byte>, IJsonFormatterStaticDefault<List<Byte>, Byte, ByteUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Byte>, Byte> Default {get;} = new ByteUtf8ListFormatter();
        private static readonly ByteUtf8Formatter ElementFormatter = (ByteUtf8Formatter) ByteUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Byte> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Byte>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Byte> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Byte>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt16Utf16Formatter : IJsonFormatter<UInt16, Char>, IJsonFormatterStaticDefault<UInt16, Char, UInt16Utf16Formatter>
    {
        public static IJsonFormatter<UInt16, Char> Default {get;} = new UInt16Utf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, UInt16 value)
        {
            writer.WriteUtf16UInt16(value);
        }

        public UInt16 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt16();
        }
    }
    public sealed class NullableUInt16Utf16Formatter : IJsonFormatter<UInt16?, Char>, IJsonFormatterStaticDefault<UInt16?, Char, NullableUInt16Utf16Formatter>
    {
        public static IJsonFormatter<UInt16?, Char> Default {get;} = new NullableUInt16Utf16Formatter();
        private static readonly UInt16Utf16Formatter ElementFormatter = (UInt16Utf16Formatter) UInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt16? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public UInt16? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt16Utf16ArrayFormatter : IJsonFormatter<UInt16?[], Char>, IJsonFormatterStaticDefault<UInt16?[], Char, NullableUInt16Utf16ArrayFormatter>
    {
        public static IJsonFormatter<UInt16?[], Char> Default {get;} = new NullableUInt16Utf16ArrayFormatter();
        private static readonly NullableUInt16Utf16Formatter ElementFormatter = (NullableUInt16Utf16Formatter) NullableUInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt16?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public UInt16?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt16?[] temp = null;
            UInt16?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt16?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt16Utf16ListFormatter : IJsonFormatter<List<UInt16?>, Char>, IJsonFormatterStaticDefault<List<UInt16?>, Char, NullableUInt16Utf16ListFormatter>
    {
        public static IJsonFormatter<List<UInt16?>, Char> Default {get;} = new NullableUInt16Utf16ListFormatter();
        private static readonly NullableUInt16Utf16Formatter ElementFormatter = (NullableUInt16Utf16Formatter) NullableUInt16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<UInt16?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt16?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<UInt16?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt16?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt16Utf16ArrayFormatter : IJsonFormatter<UInt16[], Char>, IJsonFormatterStaticDefault<UInt16[], Char, UInt16Utf16ArrayFormatter>
    {
        public static IJsonFormatter<UInt16[], Char> Default {get;} = new UInt16Utf16ArrayFormatter();
        private static readonly UInt16Utf16Formatter ElementFormatter = (UInt16Utf16Formatter) UInt16Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt16[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public UInt16[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt16[] temp = null;
            UInt16[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt16>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt16Utf16ListFormatter : IJsonFormatter<List<UInt16>, Char>, IJsonFormatterStaticDefault<List<UInt16>, Char, UInt16Utf16ListFormatter>
    {
        public static IJsonFormatter<List<UInt16>, Char> Default {get;} = new UInt16Utf16ListFormatter();
        private static readonly UInt16Utf16Formatter ElementFormatter = (UInt16Utf16Formatter) UInt16Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<UInt16> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt16>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<UInt16> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt16>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt16Utf8Formatter : IJsonFormatter<UInt16, Byte>, IJsonFormatterStaticDefault<UInt16, Byte, UInt16Utf8Formatter>
    {
        public static IJsonFormatter<UInt16, Byte> Default {get;} = new UInt16Utf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, UInt16 value)
        {
            writer.WriteUtf8UInt16(value);
        }

        public UInt16 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt16();
        }
    }
    public sealed class NullableUInt16Utf8Formatter : IJsonFormatter<UInt16?, Byte>, IJsonFormatterStaticDefault<UInt16?, Byte, NullableUInt16Utf8Formatter>
    {
        public static IJsonFormatter<UInt16?, Byte> Default {get;} = new NullableUInt16Utf8Formatter();
        private static readonly UInt16Utf8Formatter ElementFormatter = (UInt16Utf8Formatter) UInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt16? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public UInt16? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt16Utf8ArrayFormatter : IJsonFormatter<UInt16?[], Byte>, IJsonFormatterStaticDefault<UInt16?[], Byte, NullableUInt16Utf8ArrayFormatter>
    {
        public static IJsonFormatter<UInt16?[], Byte> Default {get;} = new NullableUInt16Utf8ArrayFormatter();
        private static readonly NullableUInt16Utf8Formatter ElementFormatter = (NullableUInt16Utf8Formatter) NullableUInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt16?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public UInt16?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt16?[] temp = null;
            UInt16?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt16?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt16Utf8ListFormatter : IJsonFormatter<List<UInt16?>, Byte>, IJsonFormatterStaticDefault<List<UInt16?>, Byte, NullableUInt16Utf8ListFormatter>
    {
        public static IJsonFormatter<List<UInt16?>, Byte> Default {get;} = new NullableUInt16Utf8ListFormatter();
        private static readonly NullableUInt16Utf8Formatter ElementFormatter = (NullableUInt16Utf8Formatter) NullableUInt16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt16?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt16?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<UInt16?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt16?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt16Utf8ArrayFormatter : IJsonFormatter<UInt16[], Byte>, IJsonFormatterStaticDefault<UInt16[], Byte, UInt16Utf8ArrayFormatter>
    {
        public static IJsonFormatter<UInt16[], Byte> Default {get;} = new UInt16Utf8ArrayFormatter();
        private static readonly UInt16Utf8Formatter ElementFormatter = (UInt16Utf8Formatter) UInt16Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt16[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public UInt16[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt16[] temp = null;
            UInt16[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt16>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt16>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt16>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt16Utf8ListFormatter : IJsonFormatter<List<UInt16>, Byte>, IJsonFormatterStaticDefault<List<UInt16>, Byte, UInt16Utf8ListFormatter>
    {
        public static IJsonFormatter<List<UInt16>, Byte> Default {get;} = new UInt16Utf8ListFormatter();
        private static readonly UInt16Utf8Formatter ElementFormatter = (UInt16Utf8Formatter) UInt16Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt16> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt16>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<UInt16> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt16>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt32Utf16Formatter : IJsonFormatter<UInt32, Char>, IJsonFormatterStaticDefault<UInt32, Char, UInt32Utf16Formatter>
    {
        public static IJsonFormatter<UInt32, Char> Default {get;} = new UInt32Utf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, UInt32 value)
        {
            writer.WriteUtf16UInt32(value);
        }

        public UInt32 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt32();
        }
    }
    public sealed class NullableUInt32Utf16Formatter : IJsonFormatter<UInt32?, Char>, IJsonFormatterStaticDefault<UInt32?, Char, NullableUInt32Utf16Formatter>
    {
        public static IJsonFormatter<UInt32?, Char> Default {get;} = new NullableUInt32Utf16Formatter();
        private static readonly UInt32Utf16Formatter ElementFormatter = (UInt32Utf16Formatter) UInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt32? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public UInt32? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt32Utf16ArrayFormatter : IJsonFormatter<UInt32?[], Char>, IJsonFormatterStaticDefault<UInt32?[], Char, NullableUInt32Utf16ArrayFormatter>
    {
        public static IJsonFormatter<UInt32?[], Char> Default {get;} = new NullableUInt32Utf16ArrayFormatter();
        private static readonly NullableUInt32Utf16Formatter ElementFormatter = (NullableUInt32Utf16Formatter) NullableUInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt32?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public UInt32?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt32?[] temp = null;
            UInt32?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt32?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt32Utf16ListFormatter : IJsonFormatter<List<UInt32?>, Char>, IJsonFormatterStaticDefault<List<UInt32?>, Char, NullableUInt32Utf16ListFormatter>
    {
        public static IJsonFormatter<List<UInt32?>, Char> Default {get;} = new NullableUInt32Utf16ListFormatter();
        private static readonly NullableUInt32Utf16Formatter ElementFormatter = (NullableUInt32Utf16Formatter) NullableUInt32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<UInt32?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt32?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<UInt32?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt32?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt32Utf16ArrayFormatter : IJsonFormatter<UInt32[], Char>, IJsonFormatterStaticDefault<UInt32[], Char, UInt32Utf16ArrayFormatter>
    {
        public static IJsonFormatter<UInt32[], Char> Default {get;} = new UInt32Utf16ArrayFormatter();
        private static readonly UInt32Utf16Formatter ElementFormatter = (UInt32Utf16Formatter) UInt32Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt32[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public UInt32[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt32[] temp = null;
            UInt32[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt32>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt32Utf16ListFormatter : IJsonFormatter<List<UInt32>, Char>, IJsonFormatterStaticDefault<List<UInt32>, Char, UInt32Utf16ListFormatter>
    {
        public static IJsonFormatter<List<UInt32>, Char> Default {get;} = new UInt32Utf16ListFormatter();
        private static readonly UInt32Utf16Formatter ElementFormatter = (UInt32Utf16Formatter) UInt32Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<UInt32> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt32>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<UInt32> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt32>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt32Utf8Formatter : IJsonFormatter<UInt32, Byte>, IJsonFormatterStaticDefault<UInt32, Byte, UInt32Utf8Formatter>
    {
        public static IJsonFormatter<UInt32, Byte> Default {get;} = new UInt32Utf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, UInt32 value)
        {
            writer.WriteUtf8UInt32(value);
        }

        public UInt32 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt32();
        }
    }
    public sealed class NullableUInt32Utf8Formatter : IJsonFormatter<UInt32?, Byte>, IJsonFormatterStaticDefault<UInt32?, Byte, NullableUInt32Utf8Formatter>
    {
        public static IJsonFormatter<UInt32?, Byte> Default {get;} = new NullableUInt32Utf8Formatter();
        private static readonly UInt32Utf8Formatter ElementFormatter = (UInt32Utf8Formatter) UInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt32? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public UInt32? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt32Utf8ArrayFormatter : IJsonFormatter<UInt32?[], Byte>, IJsonFormatterStaticDefault<UInt32?[], Byte, NullableUInt32Utf8ArrayFormatter>
    {
        public static IJsonFormatter<UInt32?[], Byte> Default {get;} = new NullableUInt32Utf8ArrayFormatter();
        private static readonly NullableUInt32Utf8Formatter ElementFormatter = (NullableUInt32Utf8Formatter) NullableUInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt32?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public UInt32?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt32?[] temp = null;
            UInt32?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt32?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt32Utf8ListFormatter : IJsonFormatter<List<UInt32?>, Byte>, IJsonFormatterStaticDefault<List<UInt32?>, Byte, NullableUInt32Utf8ListFormatter>
    {
        public static IJsonFormatter<List<UInt32?>, Byte> Default {get;} = new NullableUInt32Utf8ListFormatter();
        private static readonly NullableUInt32Utf8Formatter ElementFormatter = (NullableUInt32Utf8Formatter) NullableUInt32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt32?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt32?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<UInt32?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt32?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt32Utf8ArrayFormatter : IJsonFormatter<UInt32[], Byte>, IJsonFormatterStaticDefault<UInt32[], Byte, UInt32Utf8ArrayFormatter>
    {
        public static IJsonFormatter<UInt32[], Byte> Default {get;} = new UInt32Utf8ArrayFormatter();
        private static readonly UInt32Utf8Formatter ElementFormatter = (UInt32Utf8Formatter) UInt32Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt32[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public UInt32[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt32[] temp = null;
            UInt32[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt32>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt32>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt32>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt32Utf8ListFormatter : IJsonFormatter<List<UInt32>, Byte>, IJsonFormatterStaticDefault<List<UInt32>, Byte, UInt32Utf8ListFormatter>
    {
        public static IJsonFormatter<List<UInt32>, Byte> Default {get;} = new UInt32Utf8ListFormatter();
        private static readonly UInt32Utf8Formatter ElementFormatter = (UInt32Utf8Formatter) UInt32Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt32> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt32>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<UInt32> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt32>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt64Utf16Formatter : IJsonFormatter<UInt64, Char>, IJsonFormatterStaticDefault<UInt64, Char, UInt64Utf16Formatter>
    {
        public static IJsonFormatter<UInt64, Char> Default {get;} = new UInt64Utf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, UInt64 value)
        {
            writer.WriteUtf16UInt64(value);
        }

        public UInt64 Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16UInt64();
        }
    }
    public sealed class NullableUInt64Utf16Formatter : IJsonFormatter<UInt64?, Char>, IJsonFormatterStaticDefault<UInt64?, Char, NullableUInt64Utf16Formatter>
    {
        public static IJsonFormatter<UInt64?, Char> Default {get;} = new NullableUInt64Utf16Formatter();
        private static readonly UInt64Utf16Formatter ElementFormatter = (UInt64Utf16Formatter) UInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt64? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public UInt64? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt64Utf16ArrayFormatter : IJsonFormatter<UInt64?[], Char>, IJsonFormatterStaticDefault<UInt64?[], Char, NullableUInt64Utf16ArrayFormatter>
    {
        public static IJsonFormatter<UInt64?[], Char> Default {get;} = new NullableUInt64Utf16ArrayFormatter();
        private static readonly NullableUInt64Utf16Formatter ElementFormatter = (NullableUInt64Utf16Formatter) NullableUInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt64?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public UInt64?[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt64?[] temp = null;
            UInt64?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt64?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt64Utf16ListFormatter : IJsonFormatter<List<UInt64?>, Char>, IJsonFormatterStaticDefault<List<UInt64?>, Char, NullableUInt64Utf16ListFormatter>
    {
        public static IJsonFormatter<List<UInt64?>, Char> Default {get;} = new NullableUInt64Utf16ListFormatter();
        private static readonly NullableUInt64Utf16Formatter ElementFormatter = (NullableUInt64Utf16Formatter) NullableUInt64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<UInt64?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt64?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<UInt64?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt64?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt64Utf16ArrayFormatter : IJsonFormatter<UInt64[], Char>, IJsonFormatterStaticDefault<UInt64[], Char, UInt64Utf16ArrayFormatter>
    {
        public static IJsonFormatter<UInt64[], Char> Default {get;} = new UInt64Utf16ArrayFormatter();
        private static readonly UInt64Utf16Formatter ElementFormatter = (UInt64Utf16Formatter) UInt64Utf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, UInt64[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public UInt64[] Deserialize(ref JsonReader<Char> reader)
        {
            UInt64[] temp = null;
            UInt64[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt64>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt64Utf16ListFormatter : IJsonFormatter<List<UInt64>, Char>, IJsonFormatterStaticDefault<List<UInt64>, Char, UInt64Utf16ListFormatter>
    {
        public static IJsonFormatter<List<UInt64>, Char> Default {get;} = new UInt64Utf16ListFormatter();
        private static readonly UInt64Utf16Formatter ElementFormatter = (UInt64Utf16Formatter) UInt64Utf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<UInt64> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt64>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<UInt64> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<UInt64>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UInt64Utf8Formatter : IJsonFormatter<UInt64, Byte>, IJsonFormatterStaticDefault<UInt64, Byte, UInt64Utf8Formatter>
    {
        public static IJsonFormatter<UInt64, Byte> Default {get;} = new UInt64Utf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, UInt64 value)
        {
            writer.WriteUtf8UInt64(value);
        }

        public UInt64 Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8UInt64();
        }
    }
    public sealed class NullableUInt64Utf8Formatter : IJsonFormatter<UInt64?, Byte>, IJsonFormatterStaticDefault<UInt64?, Byte, NullableUInt64Utf8Formatter>
    {
        public static IJsonFormatter<UInt64?, Byte> Default {get;} = new NullableUInt64Utf8Formatter();
        private static readonly UInt64Utf8Formatter ElementFormatter = (UInt64Utf8Formatter) UInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt64? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public UInt64? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableUInt64Utf8ArrayFormatter : IJsonFormatter<UInt64?[], Byte>, IJsonFormatterStaticDefault<UInt64?[], Byte, NullableUInt64Utf8ArrayFormatter>
    {
        public static IJsonFormatter<UInt64?[], Byte> Default {get;} = new NullableUInt64Utf8ArrayFormatter();
        private static readonly NullableUInt64Utf8Formatter ElementFormatter = (NullableUInt64Utf8Formatter) NullableUInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt64?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public UInt64?[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt64?[] temp = null;
            UInt64?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt64?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableUInt64Utf8ListFormatter : IJsonFormatter<List<UInt64?>, Byte>, IJsonFormatterStaticDefault<List<UInt64?>, Byte, NullableUInt64Utf8ListFormatter>
    {
        public static IJsonFormatter<List<UInt64?>, Byte> Default {get;} = new NullableUInt64Utf8ListFormatter();
        private static readonly NullableUInt64Utf8Formatter ElementFormatter = (NullableUInt64Utf8Formatter) NullableUInt64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt64?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt64?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<UInt64?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt64?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class UInt64Utf8ArrayFormatter : IJsonFormatter<UInt64[], Byte>, IJsonFormatterStaticDefault<UInt64[], Byte, UInt64Utf8ArrayFormatter>
    {
        public static IJsonFormatter<UInt64[], Byte> Default {get;} = new UInt64Utf8ArrayFormatter();
        private static readonly UInt64Utf8Formatter ElementFormatter = (UInt64Utf8Formatter) UInt64Utf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, UInt64[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public UInt64[] Deserialize(ref JsonReader<Byte> reader)
        {
            UInt64[] temp = null;
            UInt64[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<UInt64>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<UInt64>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<UInt64>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UInt64Utf8ListFormatter : IJsonFormatter<List<UInt64>, Byte>, IJsonFormatterStaticDefault<List<UInt64>, Byte, UInt64Utf8ListFormatter>
    {
        public static IJsonFormatter<List<UInt64>, Byte> Default {get;} = new UInt64Utf8ListFormatter();
        private static readonly UInt64Utf8Formatter ElementFormatter = (UInt64Utf8Formatter) UInt64Utf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<UInt64> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<UInt64>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<UInt64> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<UInt64>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class SingleUtf16Formatter : IJsonFormatter<Single, Char>, IJsonFormatterStaticDefault<Single, Char, SingleUtf16Formatter>
    {
        public static IJsonFormatter<Single, Char> Default {get;} = new SingleUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Single value)
        {
            writer.WriteUtf16Single(value);
        }

        public Single Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Single();
        }
    }
    public sealed class NullableSingleUtf16Formatter : IJsonFormatter<Single?, Char>, IJsonFormatterStaticDefault<Single?, Char, NullableSingleUtf16Formatter>
    {
        public static IJsonFormatter<Single?, Char> Default {get;} = new NullableSingleUtf16Formatter();
        private static readonly SingleUtf16Formatter ElementFormatter = (SingleUtf16Formatter) SingleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Single? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Single? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSingleUtf16ArrayFormatter : IJsonFormatter<Single?[], Char>, IJsonFormatterStaticDefault<Single?[], Char, NullableSingleUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Single?[], Char> Default {get;} = new NullableSingleUtf16ArrayFormatter();
        private static readonly NullableSingleUtf16Formatter ElementFormatter = (NullableSingleUtf16Formatter) NullableSingleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Single?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Single?[] Deserialize(ref JsonReader<Char> reader)
        {
            Single?[] temp = null;
            Single?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Single?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableSingleUtf16ListFormatter : IJsonFormatter<List<Single?>, Char>, IJsonFormatterStaticDefault<List<Single?>, Char, NullableSingleUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Single?>, Char> Default {get;} = new NullableSingleUtf16ListFormatter();
        private static readonly NullableSingleUtf16Formatter ElementFormatter = (NullableSingleUtf16Formatter) NullableSingleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Single?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Single?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Single?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Single?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SingleUtf16ArrayFormatter : IJsonFormatter<Single[], Char>, IJsonFormatterStaticDefault<Single[], Char, SingleUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Single[], Char> Default {get;} = new SingleUtf16ArrayFormatter();
        private static readonly SingleUtf16Formatter ElementFormatter = (SingleUtf16Formatter) SingleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Single[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Single[] Deserialize(ref JsonReader<Char> reader)
        {
            Single[] temp = null;
            Single[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Single>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SingleUtf16ListFormatter : IJsonFormatter<List<Single>, Char>, IJsonFormatterStaticDefault<List<Single>, Char, SingleUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Single>, Char> Default {get;} = new SingleUtf16ListFormatter();
        private static readonly SingleUtf16Formatter ElementFormatter = (SingleUtf16Formatter) SingleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Single> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Single>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Single> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Single>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class SingleUtf8Formatter : IJsonFormatter<Single, Byte>, IJsonFormatterStaticDefault<Single, Byte, SingleUtf8Formatter>
    {
        public static IJsonFormatter<Single, Byte> Default {get;} = new SingleUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Single value)
        {
            writer.WriteUtf8Single(value);
        }

        public Single Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Single();
        }
    }
    public sealed class NullableSingleUtf8Formatter : IJsonFormatter<Single?, Byte>, IJsonFormatterStaticDefault<Single?, Byte, NullableSingleUtf8Formatter>
    {
        public static IJsonFormatter<Single?, Byte> Default {get;} = new NullableSingleUtf8Formatter();
        private static readonly SingleUtf8Formatter ElementFormatter = (SingleUtf8Formatter) SingleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Single? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Single? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableSingleUtf8ArrayFormatter : IJsonFormatter<Single?[], Byte>, IJsonFormatterStaticDefault<Single?[], Byte, NullableSingleUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Single?[], Byte> Default {get;} = new NullableSingleUtf8ArrayFormatter();
        private static readonly NullableSingleUtf8Formatter ElementFormatter = (NullableSingleUtf8Formatter) NullableSingleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Single?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Single?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Single?[] temp = null;
            Single?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Single?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableSingleUtf8ListFormatter : IJsonFormatter<List<Single?>, Byte>, IJsonFormatterStaticDefault<List<Single?>, Byte, NullableSingleUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Single?>, Byte> Default {get;} = new NullableSingleUtf8ListFormatter();
        private static readonly NullableSingleUtf8Formatter ElementFormatter = (NullableSingleUtf8Formatter) NullableSingleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Single?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Single?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Single?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Single?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class SingleUtf8ArrayFormatter : IJsonFormatter<Single[], Byte>, IJsonFormatterStaticDefault<Single[], Byte, SingleUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Single[], Byte> Default {get;} = new SingleUtf8ArrayFormatter();
        private static readonly SingleUtf8Formatter ElementFormatter = (SingleUtf8Formatter) SingleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Single[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Single[] Deserialize(ref JsonReader<Byte> reader)
        {
            Single[] temp = null;
            Single[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Single>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Single>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Single>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class SingleUtf8ListFormatter : IJsonFormatter<List<Single>, Byte>, IJsonFormatterStaticDefault<List<Single>, Byte, SingleUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Single>, Byte> Default {get;} = new SingleUtf8ListFormatter();
        private static readonly SingleUtf8Formatter ElementFormatter = (SingleUtf8Formatter) SingleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Single> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Single>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Single> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Single>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DoubleUtf16Formatter : IJsonFormatter<Double, Char>, IJsonFormatterStaticDefault<Double, Char, DoubleUtf16Formatter>
    {
        public static IJsonFormatter<Double, Char> Default {get;} = new DoubleUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Double value)
        {
            writer.WriteUtf16Double(value);
        }

        public Double Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Double();
        }
    }
    public sealed class NullableDoubleUtf16Formatter : IJsonFormatter<Double?, Char>, IJsonFormatterStaticDefault<Double?, Char, NullableDoubleUtf16Formatter>
    {
        public static IJsonFormatter<Double?, Char> Default {get;} = new NullableDoubleUtf16Formatter();
        private static readonly DoubleUtf16Formatter ElementFormatter = (DoubleUtf16Formatter) DoubleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Double? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Double? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDoubleUtf16ArrayFormatter : IJsonFormatter<Double?[], Char>, IJsonFormatterStaticDefault<Double?[], Char, NullableDoubleUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Double?[], Char> Default {get;} = new NullableDoubleUtf16ArrayFormatter();
        private static readonly NullableDoubleUtf16Formatter ElementFormatter = (NullableDoubleUtf16Formatter) NullableDoubleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Double?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Double?[] Deserialize(ref JsonReader<Char> reader)
        {
            Double?[] temp = null;
            Double?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Double?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDoubleUtf16ListFormatter : IJsonFormatter<List<Double?>, Char>, IJsonFormatterStaticDefault<List<Double?>, Char, NullableDoubleUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Double?>, Char> Default {get;} = new NullableDoubleUtf16ListFormatter();
        private static readonly NullableDoubleUtf16Formatter ElementFormatter = (NullableDoubleUtf16Formatter) NullableDoubleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Double?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Double?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Double?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Double?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DoubleUtf16ArrayFormatter : IJsonFormatter<Double[], Char>, IJsonFormatterStaticDefault<Double[], Char, DoubleUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Double[], Char> Default {get;} = new DoubleUtf16ArrayFormatter();
        private static readonly DoubleUtf16Formatter ElementFormatter = (DoubleUtf16Formatter) DoubleUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Double[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Double[] Deserialize(ref JsonReader<Char> reader)
        {
            Double[] temp = null;
            Double[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Double>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DoubleUtf16ListFormatter : IJsonFormatter<List<Double>, Char>, IJsonFormatterStaticDefault<List<Double>, Char, DoubleUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Double>, Char> Default {get;} = new DoubleUtf16ListFormatter();
        private static readonly DoubleUtf16Formatter ElementFormatter = (DoubleUtf16Formatter) DoubleUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Double> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Double>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Double> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Double>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DoubleUtf8Formatter : IJsonFormatter<Double, Byte>, IJsonFormatterStaticDefault<Double, Byte, DoubleUtf8Formatter>
    {
        public static IJsonFormatter<Double, Byte> Default {get;} = new DoubleUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Double value)
        {
            writer.WriteUtf8Double(value);
        }

        public Double Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Double();
        }
    }
    public sealed class NullableDoubleUtf8Formatter : IJsonFormatter<Double?, Byte>, IJsonFormatterStaticDefault<Double?, Byte, NullableDoubleUtf8Formatter>
    {
        public static IJsonFormatter<Double?, Byte> Default {get;} = new NullableDoubleUtf8Formatter();
        private static readonly DoubleUtf8Formatter ElementFormatter = (DoubleUtf8Formatter) DoubleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Double? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Double? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDoubleUtf8ArrayFormatter : IJsonFormatter<Double?[], Byte>, IJsonFormatterStaticDefault<Double?[], Byte, NullableDoubleUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Double?[], Byte> Default {get;} = new NullableDoubleUtf8ArrayFormatter();
        private static readonly NullableDoubleUtf8Formatter ElementFormatter = (NullableDoubleUtf8Formatter) NullableDoubleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Double?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Double?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Double?[] temp = null;
            Double?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Double?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDoubleUtf8ListFormatter : IJsonFormatter<List<Double?>, Byte>, IJsonFormatterStaticDefault<List<Double?>, Byte, NullableDoubleUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Double?>, Byte> Default {get;} = new NullableDoubleUtf8ListFormatter();
        private static readonly NullableDoubleUtf8Formatter ElementFormatter = (NullableDoubleUtf8Formatter) NullableDoubleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Double?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Double?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Double?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Double?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DoubleUtf8ArrayFormatter : IJsonFormatter<Double[], Byte>, IJsonFormatterStaticDefault<Double[], Byte, DoubleUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Double[], Byte> Default {get;} = new DoubleUtf8ArrayFormatter();
        private static readonly DoubleUtf8Formatter ElementFormatter = (DoubleUtf8Formatter) DoubleUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Double[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Double[] Deserialize(ref JsonReader<Byte> reader)
        {
            Double[] temp = null;
            Double[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Double>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Double>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Double>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DoubleUtf8ListFormatter : IJsonFormatter<List<Double>, Byte>, IJsonFormatterStaticDefault<List<Double>, Byte, DoubleUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Double>, Byte> Default {get;} = new DoubleUtf8ListFormatter();
        private static readonly DoubleUtf8Formatter ElementFormatter = (DoubleUtf8Formatter) DoubleUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Double> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Double>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Double> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Double>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DecimalUtf16Formatter : IJsonFormatter<Decimal, Char>, IJsonFormatterStaticDefault<Decimal, Char, DecimalUtf16Formatter>
    {
        public static IJsonFormatter<Decimal, Char> Default {get;} = new DecimalUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Decimal value)
        {
            writer.WriteUtf16Decimal(value);
        }

        public Decimal Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Decimal();
        }
    }
    public sealed class NullableDecimalUtf16Formatter : IJsonFormatter<Decimal?, Char>, IJsonFormatterStaticDefault<Decimal?, Char, NullableDecimalUtf16Formatter>
    {
        public static IJsonFormatter<Decimal?, Char> Default {get;} = new NullableDecimalUtf16Formatter();
        private static readonly DecimalUtf16Formatter ElementFormatter = (DecimalUtf16Formatter) DecimalUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Decimal? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Decimal? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDecimalUtf16ArrayFormatter : IJsonFormatter<Decimal?[], Char>, IJsonFormatterStaticDefault<Decimal?[], Char, NullableDecimalUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Decimal?[], Char> Default {get;} = new NullableDecimalUtf16ArrayFormatter();
        private static readonly NullableDecimalUtf16Formatter ElementFormatter = (NullableDecimalUtf16Formatter) NullableDecimalUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Decimal?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Decimal?[] Deserialize(ref JsonReader<Char> reader)
        {
            Decimal?[] temp = null;
            Decimal?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Decimal?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDecimalUtf16ListFormatter : IJsonFormatter<List<Decimal?>, Char>, IJsonFormatterStaticDefault<List<Decimal?>, Char, NullableDecimalUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Decimal?>, Char> Default {get;} = new NullableDecimalUtf16ListFormatter();
        private static readonly NullableDecimalUtf16Formatter ElementFormatter = (NullableDecimalUtf16Formatter) NullableDecimalUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Decimal?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Decimal?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Decimal?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Decimal?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DecimalUtf16ArrayFormatter : IJsonFormatter<Decimal[], Char>, IJsonFormatterStaticDefault<Decimal[], Char, DecimalUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Decimal[], Char> Default {get;} = new DecimalUtf16ArrayFormatter();
        private static readonly DecimalUtf16Formatter ElementFormatter = (DecimalUtf16Formatter) DecimalUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Decimal[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Decimal[] Deserialize(ref JsonReader<Char> reader)
        {
            Decimal[] temp = null;
            Decimal[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Decimal>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DecimalUtf16ListFormatter : IJsonFormatter<List<Decimal>, Char>, IJsonFormatterStaticDefault<List<Decimal>, Char, DecimalUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Decimal>, Char> Default {get;} = new DecimalUtf16ListFormatter();
        private static readonly DecimalUtf16Formatter ElementFormatter = (DecimalUtf16Formatter) DecimalUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Decimal> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Decimal>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Decimal> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Decimal>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DecimalUtf8Formatter : IJsonFormatter<Decimal, Byte>, IJsonFormatterStaticDefault<Decimal, Byte, DecimalUtf8Formatter>
    {
        public static IJsonFormatter<Decimal, Byte> Default {get;} = new DecimalUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Decimal value)
        {
            writer.WriteUtf8Decimal(value);
        }

        public Decimal Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Decimal();
        }
    }
    public sealed class NullableDecimalUtf8Formatter : IJsonFormatter<Decimal?, Byte>, IJsonFormatterStaticDefault<Decimal?, Byte, NullableDecimalUtf8Formatter>
    {
        public static IJsonFormatter<Decimal?, Byte> Default {get;} = new NullableDecimalUtf8Formatter();
        private static readonly DecimalUtf8Formatter ElementFormatter = (DecimalUtf8Formatter) DecimalUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Decimal? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Decimal? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDecimalUtf8ArrayFormatter : IJsonFormatter<Decimal?[], Byte>, IJsonFormatterStaticDefault<Decimal?[], Byte, NullableDecimalUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Decimal?[], Byte> Default {get;} = new NullableDecimalUtf8ArrayFormatter();
        private static readonly NullableDecimalUtf8Formatter ElementFormatter = (NullableDecimalUtf8Formatter) NullableDecimalUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Decimal?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Decimal?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Decimal?[] temp = null;
            Decimal?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Decimal?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDecimalUtf8ListFormatter : IJsonFormatter<List<Decimal?>, Byte>, IJsonFormatterStaticDefault<List<Decimal?>, Byte, NullableDecimalUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Decimal?>, Byte> Default {get;} = new NullableDecimalUtf8ListFormatter();
        private static readonly NullableDecimalUtf8Formatter ElementFormatter = (NullableDecimalUtf8Formatter) NullableDecimalUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Decimal?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Decimal?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Decimal?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Decimal?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DecimalUtf8ArrayFormatter : IJsonFormatter<Decimal[], Byte>, IJsonFormatterStaticDefault<Decimal[], Byte, DecimalUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Decimal[], Byte> Default {get;} = new DecimalUtf8ArrayFormatter();
        private static readonly DecimalUtf8Formatter ElementFormatter = (DecimalUtf8Formatter) DecimalUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Decimal[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Decimal[] Deserialize(ref JsonReader<Byte> reader)
        {
            Decimal[] temp = null;
            Decimal[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Decimal>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Decimal>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Decimal>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DecimalUtf8ListFormatter : IJsonFormatter<List<Decimal>, Byte>, IJsonFormatterStaticDefault<List<Decimal>, Byte, DecimalUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Decimal>, Byte> Default {get;} = new DecimalUtf8ListFormatter();
        private static readonly DecimalUtf8Formatter ElementFormatter = (DecimalUtf8Formatter) DecimalUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Decimal> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Decimal>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Decimal> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Decimal>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class BooleanUtf16Formatter : IJsonFormatter<Boolean, Char>, IJsonFormatterStaticDefault<Boolean, Char, BooleanUtf16Formatter>
    {
        public static IJsonFormatter<Boolean, Char> Default {get;} = new BooleanUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Boolean value)
        {
            writer.WriteUtf16Boolean(value);
        }

        public Boolean Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Boolean();
        }
    }
    public sealed class NullableBooleanUtf16Formatter : IJsonFormatter<Boolean?, Char>, IJsonFormatterStaticDefault<Boolean?, Char, NullableBooleanUtf16Formatter>
    {
        public static IJsonFormatter<Boolean?, Char> Default {get;} = new NullableBooleanUtf16Formatter();
        private static readonly BooleanUtf16Formatter ElementFormatter = (BooleanUtf16Formatter) BooleanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Boolean? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Boolean? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableBooleanUtf16ArrayFormatter : IJsonFormatter<Boolean?[], Char>, IJsonFormatterStaticDefault<Boolean?[], Char, NullableBooleanUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Boolean?[], Char> Default {get;} = new NullableBooleanUtf16ArrayFormatter();
        private static readonly NullableBooleanUtf16Formatter ElementFormatter = (NullableBooleanUtf16Formatter) NullableBooleanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Boolean?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Boolean?[] Deserialize(ref JsonReader<Char> reader)
        {
            Boolean?[] temp = null;
            Boolean?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Boolean?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableBooleanUtf16ListFormatter : IJsonFormatter<List<Boolean?>, Char>, IJsonFormatterStaticDefault<List<Boolean?>, Char, NullableBooleanUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Boolean?>, Char> Default {get;} = new NullableBooleanUtf16ListFormatter();
        private static readonly NullableBooleanUtf16Formatter ElementFormatter = (NullableBooleanUtf16Formatter) NullableBooleanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Boolean?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Boolean?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Boolean?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Boolean?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class BooleanUtf16ArrayFormatter : IJsonFormatter<Boolean[], Char>, IJsonFormatterStaticDefault<Boolean[], Char, BooleanUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Boolean[], Char> Default {get;} = new BooleanUtf16ArrayFormatter();
        private static readonly BooleanUtf16Formatter ElementFormatter = (BooleanUtf16Formatter) BooleanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Boolean[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Boolean[] Deserialize(ref JsonReader<Char> reader)
        {
            Boolean[] temp = null;
            Boolean[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Boolean>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class BooleanUtf16ListFormatter : IJsonFormatter<List<Boolean>, Char>, IJsonFormatterStaticDefault<List<Boolean>, Char, BooleanUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Boolean>, Char> Default {get;} = new BooleanUtf16ListFormatter();
        private static readonly BooleanUtf16Formatter ElementFormatter = (BooleanUtf16Formatter) BooleanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Boolean> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Boolean>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Boolean> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Boolean>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class BooleanUtf8Formatter : IJsonFormatter<Boolean, Byte>, IJsonFormatterStaticDefault<Boolean, Byte, BooleanUtf8Formatter>
    {
        public static IJsonFormatter<Boolean, Byte> Default {get;} = new BooleanUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Boolean value)
        {
            writer.WriteUtf8Boolean(value);
        }

        public Boolean Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Boolean();
        }
    }
    public sealed class NullableBooleanUtf8Formatter : IJsonFormatter<Boolean?, Byte>, IJsonFormatterStaticDefault<Boolean?, Byte, NullableBooleanUtf8Formatter>
    {
        public static IJsonFormatter<Boolean?, Byte> Default {get;} = new NullableBooleanUtf8Formatter();
        private static readonly BooleanUtf8Formatter ElementFormatter = (BooleanUtf8Formatter) BooleanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Boolean? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Boolean? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableBooleanUtf8ArrayFormatter : IJsonFormatter<Boolean?[], Byte>, IJsonFormatterStaticDefault<Boolean?[], Byte, NullableBooleanUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Boolean?[], Byte> Default {get;} = new NullableBooleanUtf8ArrayFormatter();
        private static readonly NullableBooleanUtf8Formatter ElementFormatter = (NullableBooleanUtf8Formatter) NullableBooleanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Boolean?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Boolean?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Boolean?[] temp = null;
            Boolean?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Boolean?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableBooleanUtf8ListFormatter : IJsonFormatter<List<Boolean?>, Byte>, IJsonFormatterStaticDefault<List<Boolean?>, Byte, NullableBooleanUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Boolean?>, Byte> Default {get;} = new NullableBooleanUtf8ListFormatter();
        private static readonly NullableBooleanUtf8Formatter ElementFormatter = (NullableBooleanUtf8Formatter) NullableBooleanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Boolean?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Boolean?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Boolean?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Boolean?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class BooleanUtf8ArrayFormatter : IJsonFormatter<Boolean[], Byte>, IJsonFormatterStaticDefault<Boolean[], Byte, BooleanUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Boolean[], Byte> Default {get;} = new BooleanUtf8ArrayFormatter();
        private static readonly BooleanUtf8Formatter ElementFormatter = (BooleanUtf8Formatter) BooleanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Boolean[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Boolean[] Deserialize(ref JsonReader<Byte> reader)
        {
            Boolean[] temp = null;
            Boolean[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Boolean>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Boolean>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Boolean>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class BooleanUtf8ListFormatter : IJsonFormatter<List<Boolean>, Byte>, IJsonFormatterStaticDefault<List<Boolean>, Byte, BooleanUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Boolean>, Byte> Default {get;} = new BooleanUtf8ListFormatter();
        private static readonly BooleanUtf8Formatter ElementFormatter = (BooleanUtf8Formatter) BooleanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Boolean> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Boolean>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Boolean> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Boolean>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class CharUtf16Formatter : IJsonFormatter<Char, Char>, IJsonFormatterStaticDefault<Char, Char, CharUtf16Formatter>
    {
        public static IJsonFormatter<Char, Char> Default {get;} = new CharUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Char value)
        {
            writer.WriteUtf16Char(value);
        }

        public Char Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Char();
        }
    }
    public sealed class NullableCharUtf16Formatter : IJsonFormatter<Char?, Char>, IJsonFormatterStaticDefault<Char?, Char, NullableCharUtf16Formatter>
    {
        public static IJsonFormatter<Char?, Char> Default {get;} = new NullableCharUtf16Formatter();
        private static readonly CharUtf16Formatter ElementFormatter = (CharUtf16Formatter) CharUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Char? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Char? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableCharUtf16ArrayFormatter : IJsonFormatter<Char?[], Char>, IJsonFormatterStaticDefault<Char?[], Char, NullableCharUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Char?[], Char> Default {get;} = new NullableCharUtf16ArrayFormatter();
        private static readonly NullableCharUtf16Formatter ElementFormatter = (NullableCharUtf16Formatter) NullableCharUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Char?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Char?[] Deserialize(ref JsonReader<Char> reader)
        {
            Char?[] temp = null;
            Char?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Char?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableCharUtf16ListFormatter : IJsonFormatter<List<Char?>, Char>, IJsonFormatterStaticDefault<List<Char?>, Char, NullableCharUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Char?>, Char> Default {get;} = new NullableCharUtf16ListFormatter();
        private static readonly NullableCharUtf16Formatter ElementFormatter = (NullableCharUtf16Formatter) NullableCharUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Char?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Char?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Char?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Char?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class CharUtf16ArrayFormatter : IJsonFormatter<Char[], Char>, IJsonFormatterStaticDefault<Char[], Char, CharUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Char[], Char> Default {get;} = new CharUtf16ArrayFormatter();
        private static readonly CharUtf16Formatter ElementFormatter = (CharUtf16Formatter) CharUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Char[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Char[] Deserialize(ref JsonReader<Char> reader)
        {
            Char[] temp = null;
            Char[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Char>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class CharUtf16ListFormatter : IJsonFormatter<List<Char>, Char>, IJsonFormatterStaticDefault<List<Char>, Char, CharUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Char>, Char> Default {get;} = new CharUtf16ListFormatter();
        private static readonly CharUtf16Formatter ElementFormatter = (CharUtf16Formatter) CharUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Char> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Char>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Char> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Char>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class CharUtf8Formatter : IJsonFormatter<Char, Byte>, IJsonFormatterStaticDefault<Char, Byte, CharUtf8Formatter>
    {
        public static IJsonFormatter<Char, Byte> Default {get;} = new CharUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Char value)
        {
            writer.WriteUtf8Char(value);
        }

        public Char Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Char();
        }
    }
    public sealed class NullableCharUtf8Formatter : IJsonFormatter<Char?, Byte>, IJsonFormatterStaticDefault<Char?, Byte, NullableCharUtf8Formatter>
    {
        public static IJsonFormatter<Char?, Byte> Default {get;} = new NullableCharUtf8Formatter();
        private static readonly CharUtf8Formatter ElementFormatter = (CharUtf8Formatter) CharUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Char? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Char? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableCharUtf8ArrayFormatter : IJsonFormatter<Char?[], Byte>, IJsonFormatterStaticDefault<Char?[], Byte, NullableCharUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Char?[], Byte> Default {get;} = new NullableCharUtf8ArrayFormatter();
        private static readonly NullableCharUtf8Formatter ElementFormatter = (NullableCharUtf8Formatter) NullableCharUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Char?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Char?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Char?[] temp = null;
            Char?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Char?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableCharUtf8ListFormatter : IJsonFormatter<List<Char?>, Byte>, IJsonFormatterStaticDefault<List<Char?>, Byte, NullableCharUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Char?>, Byte> Default {get;} = new NullableCharUtf8ListFormatter();
        private static readonly NullableCharUtf8Formatter ElementFormatter = (NullableCharUtf8Formatter) NullableCharUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Char?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Char?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Char?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Char?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class CharUtf8ArrayFormatter : IJsonFormatter<Char[], Byte>, IJsonFormatterStaticDefault<Char[], Byte, CharUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Char[], Byte> Default {get;} = new CharUtf8ArrayFormatter();
        private static readonly CharUtf8Formatter ElementFormatter = (CharUtf8Formatter) CharUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Char[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Char[] Deserialize(ref JsonReader<Byte> reader)
        {
            Char[] temp = null;
            Char[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Char>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Char>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Char>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class CharUtf8ListFormatter : IJsonFormatter<List<Char>, Byte>, IJsonFormatterStaticDefault<List<Char>, Byte, CharUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Char>, Byte> Default {get;} = new CharUtf8ListFormatter();
        private static readonly CharUtf8Formatter ElementFormatter = (CharUtf8Formatter) CharUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Char> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Char>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Char> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Char>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeUtf16Formatter : IJsonFormatter<DateTime, Char>, IJsonFormatterStaticDefault<DateTime, Char, DateTimeUtf16Formatter>
    {
        public static IJsonFormatter<DateTime, Char> Default {get;} = new DateTimeUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, DateTime value)
        {
            writer.WriteUtf16DateTime(value);
        }

        public DateTime Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16DateTime();
        }
    }
    public sealed class NullableDateTimeUtf16Formatter : IJsonFormatter<DateTime?, Char>, IJsonFormatterStaticDefault<DateTime?, Char, NullableDateTimeUtf16Formatter>
    {
        public static IJsonFormatter<DateTime?, Char> Default {get;} = new NullableDateTimeUtf16Formatter();
        private static readonly DateTimeUtf16Formatter ElementFormatter = (DateTimeUtf16Formatter) DateTimeUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, DateTime? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTime? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeUtf16ArrayFormatter : IJsonFormatter<DateTime?[], Char>, IJsonFormatterStaticDefault<DateTime?[], Char, NullableDateTimeUtf16ArrayFormatter>
    {
        public static IJsonFormatter<DateTime?[], Char> Default {get;} = new NullableDateTimeUtf16ArrayFormatter();
        private static readonly NullableDateTimeUtf16Formatter ElementFormatter = (NullableDateTimeUtf16Formatter) NullableDateTimeUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, DateTime?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTime?[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeUtf16ListFormatter : IJsonFormatter<List<DateTime?>, Char>, IJsonFormatterStaticDefault<List<DateTime?>, Char, NullableDateTimeUtf16ListFormatter>
    {
        public static IJsonFormatter<List<DateTime?>, Char> Default {get;} = new NullableDateTimeUtf16ListFormatter();
        private static readonly NullableDateTimeUtf16Formatter ElementFormatter = (NullableDateTimeUtf16Formatter) NullableDateTimeUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<DateTime?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTime?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTime?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeUtf16ArrayFormatter : IJsonFormatter<DateTime[], Char>, IJsonFormatterStaticDefault<DateTime[], Char, DateTimeUtf16ArrayFormatter>
    {
        public static IJsonFormatter<DateTime[], Char> Default {get;} = new DateTimeUtf16ArrayFormatter();
        private static readonly DateTimeUtf16Formatter ElementFormatter = (DateTimeUtf16Formatter) DateTimeUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, DateTime[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTime[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeUtf16ListFormatter : IJsonFormatter<List<DateTime>, Char>, IJsonFormatterStaticDefault<List<DateTime>, Char, DateTimeUtf16ListFormatter>
    {
        public static IJsonFormatter<List<DateTime>, Char> Default {get;} = new DateTimeUtf16ListFormatter();
        private static readonly DateTimeUtf16Formatter ElementFormatter = (DateTimeUtf16Formatter) DateTimeUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<DateTime> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTime>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTime> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeUtf8Formatter : IJsonFormatter<DateTime, Byte>, IJsonFormatterStaticDefault<DateTime, Byte, DateTimeUtf8Formatter>
    {
        public static IJsonFormatter<DateTime, Byte> Default {get;} = new DateTimeUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, DateTime value)
        {
            writer.WriteUtf8DateTime(value);
        }

        public DateTime Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8DateTime();
        }
    }
    public sealed class NullableDateTimeUtf8Formatter : IJsonFormatter<DateTime?, Byte>, IJsonFormatterStaticDefault<DateTime?, Byte, NullableDateTimeUtf8Formatter>
    {
        public static IJsonFormatter<DateTime?, Byte> Default {get;} = new NullableDateTimeUtf8Formatter();
        private static readonly DateTimeUtf8Formatter ElementFormatter = (DateTimeUtf8Formatter) DateTimeUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, DateTime? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTime? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeUtf8ArrayFormatter : IJsonFormatter<DateTime?[], Byte>, IJsonFormatterStaticDefault<DateTime?[], Byte, NullableDateTimeUtf8ArrayFormatter>
    {
        public static IJsonFormatter<DateTime?[], Byte> Default {get;} = new NullableDateTimeUtf8ArrayFormatter();
        private static readonly NullableDateTimeUtf8Formatter ElementFormatter = (NullableDateTimeUtf8Formatter) NullableDateTimeUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, DateTime?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTime?[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTime?[] temp = null;
            DateTime?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeUtf8ListFormatter : IJsonFormatter<List<DateTime?>, Byte>, IJsonFormatterStaticDefault<List<DateTime?>, Byte, NullableDateTimeUtf8ListFormatter>
    {
        public static IJsonFormatter<List<DateTime?>, Byte> Default {get;} = new NullableDateTimeUtf8ListFormatter();
        private static readonly NullableDateTimeUtf8Formatter ElementFormatter = (NullableDateTimeUtf8Formatter) NullableDateTimeUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTime?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTime?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTime?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeUtf8ArrayFormatter : IJsonFormatter<DateTime[], Byte>, IJsonFormatterStaticDefault<DateTime[], Byte, DateTimeUtf8ArrayFormatter>
    {
        public static IJsonFormatter<DateTime[], Byte> Default {get;} = new DateTimeUtf8ArrayFormatter();
        private static readonly DateTimeUtf8Formatter ElementFormatter = (DateTimeUtf8Formatter) DateTimeUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, DateTime[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTime[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTime[] temp = null;
            DateTime[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTime>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTime>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTime>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeUtf8ListFormatter : IJsonFormatter<List<DateTime>, Byte>, IJsonFormatterStaticDefault<List<DateTime>, Byte, DateTimeUtf8ListFormatter>
    {
        public static IJsonFormatter<List<DateTime>, Byte> Default {get;} = new DateTimeUtf8ListFormatter();
        private static readonly DateTimeUtf8Formatter ElementFormatter = (DateTimeUtf8Formatter) DateTimeUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTime> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTime>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTime> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTime>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeOffsetUtf16Formatter : IJsonFormatter<DateTimeOffset, Char>, IJsonFormatterStaticDefault<DateTimeOffset, Char, DateTimeOffsetUtf16Formatter>
    {
        public static IJsonFormatter<DateTimeOffset, Char> Default {get;} = new DateTimeOffsetUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset value)
        {
            writer.WriteUtf16DateTimeOffset(value);
        }

        public DateTimeOffset Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16DateTimeOffset();
        }
    }
    public sealed class NullableDateTimeOffsetUtf16Formatter : IJsonFormatter<DateTimeOffset?, Char>, IJsonFormatterStaticDefault<DateTimeOffset?, Char, NullableDateTimeOffsetUtf16Formatter>
    {
        public static IJsonFormatter<DateTimeOffset?, Char> Default {get;} = new NullableDateTimeOffsetUtf16Formatter();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = (DateTimeOffsetUtf16Formatter) DateTimeOffsetUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTimeOffset? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ArrayFormatter : IJsonFormatter<DateTimeOffset?[], Char>, IJsonFormatterStaticDefault<DateTimeOffset?[], Char, NullableDateTimeOffsetUtf16ArrayFormatter>
    {
        public static IJsonFormatter<DateTimeOffset?[], Char> Default {get;} = new NullableDateTimeOffsetUtf16ArrayFormatter();
        private static readonly NullableDateTimeOffsetUtf16Formatter ElementFormatter = (NullableDateTimeOffsetUtf16Formatter) NullableDateTimeOffsetUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTimeOffset?[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeOffsetUtf16ListFormatter : IJsonFormatter<List<DateTimeOffset?>, Char>, IJsonFormatterStaticDefault<List<DateTimeOffset?>, Char, NullableDateTimeOffsetUtf16ListFormatter>
    {
        public static IJsonFormatter<List<DateTimeOffset?>, Char> Default {get;} = new NullableDateTimeOffsetUtf16ListFormatter();
        private static readonly NullableDateTimeOffsetUtf16Formatter ElementFormatter = (NullableDateTimeOffsetUtf16Formatter) NullableDateTimeOffsetUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<DateTimeOffset?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTimeOffset?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTimeOffset?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeOffsetUtf16ArrayFormatter : IJsonFormatter<DateTimeOffset[], Char>, IJsonFormatterStaticDefault<DateTimeOffset[], Char, DateTimeOffsetUtf16ArrayFormatter>
    {
        public static IJsonFormatter<DateTimeOffset[], Char> Default {get;} = new DateTimeOffsetUtf16ArrayFormatter();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = (DateTimeOffsetUtf16Formatter) DateTimeOffsetUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, DateTimeOffset[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public DateTimeOffset[] Deserialize(ref JsonReader<Char> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeOffsetUtf16ListFormatter : IJsonFormatter<List<DateTimeOffset>, Char>, IJsonFormatterStaticDefault<List<DateTimeOffset>, Char, DateTimeOffsetUtf16ListFormatter>
    {
        public static IJsonFormatter<List<DateTimeOffset>, Char> Default {get;} = new DateTimeOffsetUtf16ListFormatter();
        private static readonly DateTimeOffsetUtf16Formatter ElementFormatter = (DateTimeOffsetUtf16Formatter) DateTimeOffsetUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<DateTimeOffset> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTimeOffset>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<DateTimeOffset> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class DateTimeOffsetUtf8Formatter : IJsonFormatter<DateTimeOffset, Byte>, IJsonFormatterStaticDefault<DateTimeOffset, Byte, DateTimeOffsetUtf8Formatter>
    {
        public static IJsonFormatter<DateTimeOffset, Byte> Default {get;} = new DateTimeOffsetUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset value)
        {
            writer.WriteUtf8DateTimeOffset(value);
        }

        public DateTimeOffset Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8DateTimeOffset();
        }
    }
    public sealed class NullableDateTimeOffsetUtf8Formatter : IJsonFormatter<DateTimeOffset?, Byte>, IJsonFormatterStaticDefault<DateTimeOffset?, Byte, NullableDateTimeOffsetUtf8Formatter>
    {
        public static IJsonFormatter<DateTimeOffset?, Byte> Default {get;} = new NullableDateTimeOffsetUtf8Formatter();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = (DateTimeOffsetUtf8Formatter) DateTimeOffsetUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public DateTimeOffset? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ArrayFormatter : IJsonFormatter<DateTimeOffset?[], Byte>, IJsonFormatterStaticDefault<DateTimeOffset?[], Byte, NullableDateTimeOffsetUtf8ArrayFormatter>
    {
        public static IJsonFormatter<DateTimeOffset?[], Byte> Default {get;} = new NullableDateTimeOffsetUtf8ArrayFormatter();
        private static readonly NullableDateTimeOffsetUtf8Formatter ElementFormatter = (NullableDateTimeOffsetUtf8Formatter) NullableDateTimeOffsetUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTimeOffset?[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTimeOffset?[] temp = null;
            DateTimeOffset?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableDateTimeOffsetUtf8ListFormatter : IJsonFormatter<List<DateTimeOffset?>, Byte>, IJsonFormatterStaticDefault<List<DateTimeOffset?>, Byte, NullableDateTimeOffsetUtf8ListFormatter>
    {
        public static IJsonFormatter<List<DateTimeOffset?>, Byte> Default {get;} = new NullableDateTimeOffsetUtf8ListFormatter();
        private static readonly NullableDateTimeOffsetUtf8Formatter ElementFormatter = (NullableDateTimeOffsetUtf8Formatter) NullableDateTimeOffsetUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTimeOffset?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTimeOffset?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTimeOffset?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class DateTimeOffsetUtf8ArrayFormatter : IJsonFormatter<DateTimeOffset[], Byte>, IJsonFormatterStaticDefault<DateTimeOffset[], Byte, DateTimeOffsetUtf8ArrayFormatter>
    {
        public static IJsonFormatter<DateTimeOffset[], Byte> Default {get;} = new DateTimeOffsetUtf8ArrayFormatter();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = (DateTimeOffsetUtf8Formatter) DateTimeOffsetUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, DateTimeOffset[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public DateTimeOffset[] Deserialize(ref JsonReader<Byte> reader)
        {
            DateTimeOffset[] temp = null;
            DateTimeOffset[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<DateTimeOffset>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<DateTimeOffset>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<DateTimeOffset>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class DateTimeOffsetUtf8ListFormatter : IJsonFormatter<List<DateTimeOffset>, Byte>, IJsonFormatterStaticDefault<List<DateTimeOffset>, Byte, DateTimeOffsetUtf8ListFormatter>
    {
        public static IJsonFormatter<List<DateTimeOffset>, Byte> Default {get;} = new DateTimeOffsetUtf8ListFormatter();
        private static readonly DateTimeOffsetUtf8Formatter ElementFormatter = (DateTimeOffsetUtf8Formatter) DateTimeOffsetUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<DateTimeOffset> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<DateTimeOffset>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<DateTimeOffset> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<DateTimeOffset>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class TimeSpanUtf16Formatter : IJsonFormatter<TimeSpan, Char>, IJsonFormatterStaticDefault<TimeSpan, Char, TimeSpanUtf16Formatter>
    {
        public static IJsonFormatter<TimeSpan, Char> Default {get;} = new TimeSpanUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, TimeSpan value)
        {
            writer.WriteUtf16TimeSpan(value);
        }

        public TimeSpan Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16TimeSpan();
        }
    }
    public sealed class NullableTimeSpanUtf16Formatter : IJsonFormatter<TimeSpan?, Char>, IJsonFormatterStaticDefault<TimeSpan?, Char, NullableTimeSpanUtf16Formatter>
    {
        public static IJsonFormatter<TimeSpan?, Char> Default {get;} = new NullableTimeSpanUtf16Formatter();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = (TimeSpanUtf16Formatter) TimeSpanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, TimeSpan? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public TimeSpan? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableTimeSpanUtf16ArrayFormatter : IJsonFormatter<TimeSpan?[], Char>, IJsonFormatterStaticDefault<TimeSpan?[], Char, NullableTimeSpanUtf16ArrayFormatter>
    {
        public static IJsonFormatter<TimeSpan?[], Char> Default {get;} = new NullableTimeSpanUtf16ArrayFormatter();
        private static readonly NullableTimeSpanUtf16Formatter ElementFormatter = (NullableTimeSpanUtf16Formatter) NullableTimeSpanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, TimeSpan?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public TimeSpan?[] Deserialize(ref JsonReader<Char> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableTimeSpanUtf16ListFormatter : IJsonFormatter<List<TimeSpan?>, Char>, IJsonFormatterStaticDefault<List<TimeSpan?>, Char, NullableTimeSpanUtf16ListFormatter>
    {
        public static IJsonFormatter<List<TimeSpan?>, Char> Default {get;} = new NullableTimeSpanUtf16ListFormatter();
        private static readonly NullableTimeSpanUtf16Formatter ElementFormatter = (NullableTimeSpanUtf16Formatter) NullableTimeSpanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<TimeSpan?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<TimeSpan?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<TimeSpan?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class TimeSpanUtf16ArrayFormatter : IJsonFormatter<TimeSpan[], Char>, IJsonFormatterStaticDefault<TimeSpan[], Char, TimeSpanUtf16ArrayFormatter>
    {
        public static IJsonFormatter<TimeSpan[], Char> Default {get;} = new TimeSpanUtf16ArrayFormatter();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = (TimeSpanUtf16Formatter) TimeSpanUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, TimeSpan[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public TimeSpan[] Deserialize(ref JsonReader<Char> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class TimeSpanUtf16ListFormatter : IJsonFormatter<List<TimeSpan>, Char>, IJsonFormatterStaticDefault<List<TimeSpan>, Char, TimeSpanUtf16ListFormatter>
    {
        public static IJsonFormatter<List<TimeSpan>, Char> Default {get;} = new TimeSpanUtf16ListFormatter();
        private static readonly TimeSpanUtf16Formatter ElementFormatter = (TimeSpanUtf16Formatter) TimeSpanUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<TimeSpan> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<TimeSpan>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<TimeSpan> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class TimeSpanUtf8Formatter : IJsonFormatter<TimeSpan, Byte>, IJsonFormatterStaticDefault<TimeSpan, Byte, TimeSpanUtf8Formatter>
    {
        public static IJsonFormatter<TimeSpan, Byte> Default {get;} = new TimeSpanUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan value)
        {
            writer.WriteUtf8TimeSpan(value);
        }

        public TimeSpan Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8TimeSpan();
        }
    }
    public sealed class NullableTimeSpanUtf8Formatter : IJsonFormatter<TimeSpan?, Byte>, IJsonFormatterStaticDefault<TimeSpan?, Byte, NullableTimeSpanUtf8Formatter>
    {
        public static IJsonFormatter<TimeSpan?, Byte> Default {get;} = new NullableTimeSpanUtf8Formatter();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = (TimeSpanUtf8Formatter) TimeSpanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public TimeSpan? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableTimeSpanUtf8ArrayFormatter : IJsonFormatter<TimeSpan?[], Byte>, IJsonFormatterStaticDefault<TimeSpan?[], Byte, NullableTimeSpanUtf8ArrayFormatter>
    {
        public static IJsonFormatter<TimeSpan?[], Byte> Default {get;} = new NullableTimeSpanUtf8ArrayFormatter();
        private static readonly NullableTimeSpanUtf8Formatter ElementFormatter = (NullableTimeSpanUtf8Formatter) NullableTimeSpanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public TimeSpan?[] Deserialize(ref JsonReader<Byte> reader)
        {
            TimeSpan?[] temp = null;
            TimeSpan?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableTimeSpanUtf8ListFormatter : IJsonFormatter<List<TimeSpan?>, Byte>, IJsonFormatterStaticDefault<List<TimeSpan?>, Byte, NullableTimeSpanUtf8ListFormatter>
    {
        public static IJsonFormatter<List<TimeSpan?>, Byte> Default {get;} = new NullableTimeSpanUtf8ListFormatter();
        private static readonly NullableTimeSpanUtf8Formatter ElementFormatter = (NullableTimeSpanUtf8Formatter) NullableTimeSpanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<TimeSpan?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<TimeSpan?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<TimeSpan?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class TimeSpanUtf8ArrayFormatter : IJsonFormatter<TimeSpan[], Byte>, IJsonFormatterStaticDefault<TimeSpan[], Byte, TimeSpanUtf8ArrayFormatter>
    {
        public static IJsonFormatter<TimeSpan[], Byte> Default {get;} = new TimeSpanUtf8ArrayFormatter();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = (TimeSpanUtf8Formatter) TimeSpanUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, TimeSpan[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public TimeSpan[] Deserialize(ref JsonReader<Byte> reader)
        {
            TimeSpan[] temp = null;
            TimeSpan[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<TimeSpan>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<TimeSpan>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<TimeSpan>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class TimeSpanUtf8ListFormatter : IJsonFormatter<List<TimeSpan>, Byte>, IJsonFormatterStaticDefault<List<TimeSpan>, Byte, TimeSpanUtf8ListFormatter>
    {
        public static IJsonFormatter<List<TimeSpan>, Byte> Default {get;} = new TimeSpanUtf8ListFormatter();
        private static readonly TimeSpanUtf8Formatter ElementFormatter = (TimeSpanUtf8Formatter) TimeSpanUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<TimeSpan> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<TimeSpan>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<TimeSpan> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<TimeSpan>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class GuidUtf16Formatter : IJsonFormatter<Guid, Char>, IJsonFormatterStaticDefault<Guid, Char, GuidUtf16Formatter>
    {
        public static IJsonFormatter<Guid, Char> Default {get;} = new GuidUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Guid value)
        {
            writer.WriteUtf16Guid(value);
        }

        public Guid Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Guid();
        }
    }
    public sealed class NullableGuidUtf16Formatter : IJsonFormatter<Guid?, Char>, IJsonFormatterStaticDefault<Guid?, Char, NullableGuidUtf16Formatter>
    {
        public static IJsonFormatter<Guid?, Char> Default {get;} = new NullableGuidUtf16Formatter();
        private static readonly GuidUtf16Formatter ElementFormatter = (GuidUtf16Formatter) GuidUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Guid? value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Guid? Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableGuidUtf16ArrayFormatter : IJsonFormatter<Guid?[], Char>, IJsonFormatterStaticDefault<Guid?[], Char, NullableGuidUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Guid?[], Char> Default {get;} = new NullableGuidUtf16ArrayFormatter();
        private static readonly NullableGuidUtf16Formatter ElementFormatter = (NullableGuidUtf16Formatter) NullableGuidUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Guid?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Guid?[] Deserialize(ref JsonReader<Char> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableGuidUtf16ListFormatter : IJsonFormatter<List<Guid?>, Char>, IJsonFormatterStaticDefault<List<Guid?>, Char, NullableGuidUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Guid?>, Char> Default {get;} = new NullableGuidUtf16ListFormatter();
        private static readonly NullableGuidUtf16Formatter ElementFormatter = (NullableGuidUtf16Formatter) NullableGuidUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Guid?> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Guid?>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Guid?> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class GuidUtf16ArrayFormatter : IJsonFormatter<Guid[], Char>, IJsonFormatterStaticDefault<Guid[], Char, GuidUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Guid[], Char> Default {get;} = new GuidUtf16ArrayFormatter();
        private static readonly GuidUtf16Formatter ElementFormatter = (GuidUtf16Formatter) GuidUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Guid[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Guid[] Deserialize(ref JsonReader<Char> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class GuidUtf16ListFormatter : IJsonFormatter<List<Guid>, Char>, IJsonFormatterStaticDefault<List<Guid>, Char, GuidUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Guid>, Char> Default {get;} = new GuidUtf16ListFormatter();
        private static readonly GuidUtf16Formatter ElementFormatter = (GuidUtf16Formatter) GuidUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Guid> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Guid>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Guid> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class GuidUtf8Formatter : IJsonFormatter<Guid, Byte>, IJsonFormatterStaticDefault<Guid, Byte, GuidUtf8Formatter>
    {
        public static IJsonFormatter<Guid, Byte> Default {get;} = new GuidUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Guid value)
        {
            writer.WriteUtf8Guid(value);
        }

        public Guid Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Guid();
        }
    }
    public sealed class NullableGuidUtf8Formatter : IJsonFormatter<Guid?, Byte>, IJsonFormatterStaticDefault<Guid?, Byte, NullableGuidUtf8Formatter>
    {
        public static IJsonFormatter<Guid?, Byte> Default {get;} = new NullableGuidUtf8Formatter();
        private static readonly GuidUtf8Formatter ElementFormatter = (GuidUtf8Formatter) GuidUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Guid? value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }

            ElementFormatter.Serialize(ref writer, value.GetValueOrDefault());
        }

        public Guid? Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }

            return ElementFormatter.Deserialize(ref reader);
        }
    }

    public sealed class NullableGuidUtf8ArrayFormatter : IJsonFormatter<Guid?[], Byte>, IJsonFormatterStaticDefault<Guid?[], Byte, NullableGuidUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Guid?[], Byte> Default {get;} = new NullableGuidUtf8ArrayFormatter();
        private static readonly NullableGuidUtf8Formatter ElementFormatter = (NullableGuidUtf8Formatter) NullableGuidUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Guid?[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Guid?[] Deserialize(ref JsonReader<Byte> reader)
        {
            Guid?[] temp = null;
            Guid?[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid?>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid?>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid?>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class NullableGuidUtf8ListFormatter : IJsonFormatter<List<Guid?>, Byte>, IJsonFormatterStaticDefault<List<Guid?>, Byte, NullableGuidUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Guid?>, Byte> Default {get;} = new NullableGuidUtf8ListFormatter();
        private static readonly NullableGuidUtf8Formatter ElementFormatter = (NullableGuidUtf8Formatter) NullableGuidUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Guid?> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Guid?>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Guid?> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid?>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }

    public sealed class GuidUtf8ArrayFormatter : IJsonFormatter<Guid[], Byte>, IJsonFormatterStaticDefault<Guid[], Byte, GuidUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Guid[], Byte> Default {get;} = new GuidUtf8ArrayFormatter();
        private static readonly GuidUtf8Formatter ElementFormatter = (GuidUtf8Formatter) GuidUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Guid[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Guid[] Deserialize(ref JsonReader<Byte> reader)
        {
            Guid[] temp = null;
            Guid[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Guid>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Guid>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Guid>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class GuidUtf8ListFormatter : IJsonFormatter<List<Guid>, Byte>, IJsonFormatterStaticDefault<List<Guid>, Byte, GuidUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Guid>, Byte> Default {get;} = new GuidUtf8ListFormatter();
        private static readonly GuidUtf8Formatter ElementFormatter = (GuidUtf8Formatter) GuidUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Guid> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Guid>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Guid> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Guid>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class StringUtf16Formatter : IJsonFormatter<String, Char>, IJsonFormatterStaticDefault<String, Char, StringUtf16Formatter>
    {
        public static IJsonFormatter<String, Char> Default {get;} = new StringUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, String value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16String(value);
        }

        public String Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16String();
        }
    }

    public sealed class StringUtf16ArrayFormatter : IJsonFormatter<String[], Char>, IJsonFormatterStaticDefault<String[], Char, StringUtf16ArrayFormatter>
    {
        public static IJsonFormatter<String[], Char> Default {get;} = new StringUtf16ArrayFormatter();
        private static readonly StringUtf16Formatter ElementFormatter = (StringUtf16Formatter) StringUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, String[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public String[] Deserialize(ref JsonReader<Char> reader)
        {
            String[] temp = null;
            String[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<String>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class StringUtf16ListFormatter : IJsonFormatter<List<String>, Char>, IJsonFormatterStaticDefault<List<String>, Char, StringUtf16ListFormatter>
    {
        public static IJsonFormatter<List<String>, Char> Default {get;} = new StringUtf16ListFormatter();
        private static readonly StringUtf16Formatter ElementFormatter = (StringUtf16Formatter) StringUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<String> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<String>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<String> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<String>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class StringUtf8Formatter : IJsonFormatter<String, Byte>, IJsonFormatterStaticDefault<String, Byte, StringUtf8Formatter>
    {
        public static IJsonFormatter<String, Byte> Default {get;} = new StringUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, String value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8String(value);
        }

        public String Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8String();
        }
    }

    public sealed class StringUtf8ArrayFormatter : IJsonFormatter<String[], Byte>, IJsonFormatterStaticDefault<String[], Byte, StringUtf8ArrayFormatter>
    {
        public static IJsonFormatter<String[], Byte> Default {get;} = new StringUtf8ArrayFormatter();
        private static readonly StringUtf8Formatter ElementFormatter = (StringUtf8Formatter) StringUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, String[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public String[] Deserialize(ref JsonReader<Byte> reader)
        {
            String[] temp = null;
            String[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<String>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<String>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<String>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class StringUtf8ListFormatter : IJsonFormatter<List<String>, Byte>, IJsonFormatterStaticDefault<List<String>, Byte, StringUtf8ListFormatter>
    {
        public static IJsonFormatter<List<String>, Byte> Default {get;} = new StringUtf8ListFormatter();
        private static readonly StringUtf8Formatter ElementFormatter = (StringUtf8Formatter) StringUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<String> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<String>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<String> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<String>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class VersionUtf16Formatter : IJsonFormatter<Version, Char>, IJsonFormatterStaticDefault<Version, Char, VersionUtf16Formatter>
    {
        public static IJsonFormatter<Version, Char> Default {get;} = new VersionUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Version value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16Version(value);
        }

        public Version Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Version();
        }
    }

    public sealed class VersionUtf16ArrayFormatter : IJsonFormatter<Version[], Char>, IJsonFormatterStaticDefault<Version[], Char, VersionUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Version[], Char> Default {get;} = new VersionUtf16ArrayFormatter();
        private static readonly VersionUtf16Formatter ElementFormatter = (VersionUtf16Formatter) VersionUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Version[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Version[] Deserialize(ref JsonReader<Char> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class VersionUtf16ListFormatter : IJsonFormatter<List<Version>, Char>, IJsonFormatterStaticDefault<List<Version>, Char, VersionUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Version>, Char> Default {get;} = new VersionUtf16ListFormatter();
        private static readonly VersionUtf16Formatter ElementFormatter = (VersionUtf16Formatter) VersionUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Version> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Version>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Version> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class VersionUtf8Formatter : IJsonFormatter<Version, Byte>, IJsonFormatterStaticDefault<Version, Byte, VersionUtf8Formatter>
    {
        public static IJsonFormatter<Version, Byte> Default {get;} = new VersionUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Version value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8Version(value);
        }

        public Version Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Version();
        }
    }

    public sealed class VersionUtf8ArrayFormatter : IJsonFormatter<Version[], Byte>, IJsonFormatterStaticDefault<Version[], Byte, VersionUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Version[], Byte> Default {get;} = new VersionUtf8ArrayFormatter();
        private static readonly VersionUtf8Formatter ElementFormatter = (VersionUtf8Formatter) VersionUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Version[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Version[] Deserialize(ref JsonReader<Byte> reader)
        {
            Version[] temp = null;
            Version[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Version>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Version>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Version>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class VersionUtf8ListFormatter : IJsonFormatter<List<Version>, Byte>, IJsonFormatterStaticDefault<List<Version>, Byte, VersionUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Version>, Byte> Default {get;} = new VersionUtf8ListFormatter();
        private static readonly VersionUtf8Formatter ElementFormatter = (VersionUtf8Formatter) VersionUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Version> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Version>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Version> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Version>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UriUtf16Formatter : IJsonFormatter<Uri, Char>, IJsonFormatterStaticDefault<Uri, Char, UriUtf16Formatter>
    {
        public static IJsonFormatter<Uri, Char> Default {get;} = new UriUtf16Formatter();

        public void Serialize(ref JsonWriter<Char> writer, Uri value)
        {
            if(value == null)
            {
                writer.WriteUtf16Null();
                return;
            }
            writer.WriteUtf16Uri(value);
        }

        public Uri Deserialize(ref JsonReader<Char> reader)
        {
            return reader.ReadUtf16Uri();
        }
    }

    public sealed class UriUtf16ArrayFormatter : IJsonFormatter<Uri[], Char>, IJsonFormatterStaticDefault<Uri[], Char, UriUtf16ArrayFormatter>
    {
        public static IJsonFormatter<Uri[], Char> Default {get;} = new UriUtf16ArrayFormatter();
        private static readonly UriUtf16Formatter ElementFormatter = (UriUtf16Formatter) UriUtf16Formatter.Default;
        public void Serialize(ref JsonWriter<Char> writer, Uri[] value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf16EndArray();
        }

        public Uri[] Deserialize(ref JsonReader<Char> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                if (reader.ReadUtf16IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf16BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UriUtf16ListFormatter : IJsonFormatter<List<Uri>, Char>, IJsonFormatterStaticDefault<List<Uri>, Char, UriUtf16ListFormatter>
    {
        public static IJsonFormatter<List<Uri>, Char> Default {get;} = new UriUtf16ListFormatter();
        private static readonly UriUtf16Formatter ElementFormatter = (UriUtf16Formatter) UriUtf16Formatter.Default;

        public void Serialize(ref JsonWriter<Char> writer, List<Uri> value)
        {
            if (value is null)
            {
                writer.WriteUtf16Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Uri>(value);
            var valueLength = span.Length;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf16BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf16ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf16EndArray();
        }

        public List<Uri> Deserialize(ref JsonReader<Char> reader)
        {
            if (reader.ReadUtf16IsNull())
            {
                return null;
            }
            reader.ReadUtf16BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf16IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
    public sealed class UriUtf8Formatter : IJsonFormatter<Uri, Byte>, IJsonFormatterStaticDefault<Uri, Byte, UriUtf8Formatter>
    {
        public static IJsonFormatter<Uri, Byte> Default {get;} = new UriUtf8Formatter();

        public void Serialize(ref JsonWriter<Byte> writer, Uri value)
        {
            if(value == null)
            {
                writer.WriteUtf8Null();
                return;
            }
            writer.WriteUtf8Uri(value);
        }

        public Uri Deserialize(ref JsonReader<Byte> reader)
        {
            return reader.ReadUtf8Uri();
        }
    }

    public sealed class UriUtf8ArrayFormatter : IJsonFormatter<Uri[], Byte>, IJsonFormatterStaticDefault<Uri[], Byte, UriUtf8ArrayFormatter>
    {
        public static IJsonFormatter<Uri[], Byte> Default {get;} = new UriUtf8ArrayFormatter();
        private static readonly UriUtf8Formatter ElementFormatter = (UriUtf8Formatter) UriUtf8Formatter.Default;
        public void Serialize(ref JsonWriter<Byte> writer, Uri[] value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
            var valueLength = value.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }

            writer.WriteUtf8EndArray();
        }

        public Uri[] Deserialize(ref JsonReader<Byte> reader)
        {
            Uri[] temp = null;
            Uri[] result;
            try
            {
                if (reader.ReadUtf8IsNull())
                {
                    return null;
                }
                temp = ArrayPool<Uri>.Shared.Rent(4);
                reader.ReadUtf8BeginArrayOrThrow();
                var count = 0;
                while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count)) // count is already preincremented, as it counts the separators
                {
                    if (count == temp.Length)
                    {
                        FormatterUtils.GrowArray(ref temp);
                    }

                    temp[count - 1] = ElementFormatter.Deserialize(ref reader);
                }

                if (count == 0)
                {
                    result = Array.Empty<Uri>();
                }
                else
                {
                    result = FormatterUtils.CopyArray(temp, count);
                }
            }
            finally
            {
                if (temp != null)
                {
                    ArrayPool<Uri>.Shared.Return(temp);
                }
            }

            return result;
        }
    }

    public sealed class UriUtf8ListFormatter : IJsonFormatter<List<Uri>, Byte>, IJsonFormatterStaticDefault<List<Uri>, Byte, UriUtf8ListFormatter>
    {
        public static IJsonFormatter<List<Uri>, Byte> Default {get;} = new UriUtf8ListFormatter();
        private static readonly UriUtf8Formatter ElementFormatter = (UriUtf8Formatter) UriUtf8Formatter.Default;

        public void Serialize(ref JsonWriter<Byte> writer, List<Uri> value)
        {
            if (value is null)
            {
                writer.WriteUtf8Null();
                return;
            }
#if NET5_0_OR_GREATER
            var span = System.Runtime.InteropServices.CollectionsMarshal.AsSpan<Uri>(value);
            var valueLength = span.Length;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, span[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, span[i]);
                }
            }            
#else
            var valueLength = value.Count;
            writer.WriteUtf8BeginArray();
            if (valueLength > 0)
            {
                ElementFormatter.Serialize(ref writer, value[0]);
                for (var i = 1; i < valueLength; i++)
                {
                    writer.WriteUtf8ValueSeparator();
                    ElementFormatter.Serialize(ref writer, value[i]);
                }
            }
#endif
            writer.WriteUtf8EndArray();
        }

        public List<Uri> Deserialize(ref JsonReader<Byte> reader)
        {
            if (reader.ReadUtf8IsNull())
            {
                return null;
            }
            reader.ReadUtf8BeginArrayOrThrow();
            var list = new List<Uri>();
            var count = 0;
            while (!reader.TryReadUtf8IsEndArrayOrValueSeparator(ref count))
            {
                list.Add(ElementFormatter.Deserialize(ref reader));
            }

            return list;
        }
    }
}